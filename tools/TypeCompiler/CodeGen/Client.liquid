//----------------------
// <auto-generated>
// </auto-generated>
//----------------------
using System;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;

using Infusio.Model;
using LanguageExt;
using LanguageExt.TypeClasses;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;

// ReSharper disable RedundantStringInterpolation

namespace Infusio.Http
{
    using static Prelude;
    using static JsonConvert;

    public class InfusioClient
    {
        private readonly HttpClient _client;
        private readonly InfusioConfig _config;

        public InfusioClient(HttpClient client, InfusioConfig config)
        {
            _client = client;
            _config = config;
        }

        {% for op in Operations %}
        /// <summary>
        /// {{ op.Summary }}
        /// </summary>
        {% for p in op.Parameters -%}
        /// <param name="{{ p.Name }}">{{ p.Description }}</param>
        {% endfor -%}
        public Task<Either<Error, {% if op.ResponseType == 'Unit' %}Nothing{% else %}{{ op.ResponseType | normalize }}{% endif %}>> {{ op.Name }}({% for p in op.Parameters %}{{ p.Type }} {{ p.Name }}{% if p.Required == false %} = default{% endif %}{% if forloop.last == false %}, {% endif %}{% endfor %}){
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  {% for res in op.Responses -%}new KnownResponse({{ res.StatusCode }}, "{{ res.Description }}", typeof({{ res.Type | normalize }})){% if forloop.last == false %}, {% endif %}
                  {% endfor -%}
              );

            return HttpWorkflow<{% if op.ResponseType == 'Unit' %}Nothing{% else %}{{ op.ResponseType | normalize }}{% endif %}>(
                    Request(HttpMethod.{{ op.HttpMethod }}, $"{{ op.Path }}"{% if op.HasParameters %}, {% endif %}{% for p in op.Parameters %}ContentProperty("{{ p.Name }}", {{ p.Name }}){% if forloop.last == false %}, {% endif %}{% endfor -%}),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// {{ op.Summary }}
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="{{ op.Name }}"/>.</remarks>
        {% for p in op.Parameters -%}
        /// <param name="{{ p.Name }}">{{ p.Description }}</param>
        {% endfor -%}
        public Task<{% if op.ResponseType == 'Unit' %}Nothing{% else %}{{ op.ResponseType | normalize }}{% endif %}> {{ op.Name }}Unsafe({% for p in op.Parameters %}{{ p.Type }} {{ p.Name }}{% if p.Required == false %} = default{% endif %}{% if forloop.last == false %}, {% endif %}{% endfor %}) =>
        {{ op.Name }}({% for p in op.Parameters %}{{ p.Name }}{% if forloop.last == false %}, {% endif %}{% endfor %})
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Message));

        {% endfor %}

        EitherAsync<Error, T> HttpWorkflow<T>(HttpRequestMessage message, HashSet<KnownResponse.Eq, KnownResponse> responses)  where T : class =>
            from httpResponse in SendRequest(message)
            from responseType in FindResponse(httpResponse, responses)
            from result in ReadResult<T>(httpResponse, responseType)
            select result;

        static readonly JsonSerializerSettings SerializerSettings = new JsonSerializerSettings
        {
            NullValueHandling = NullValueHandling.Ignore,
            ContractResolver = new CamelCasePropertyNamesContractResolver()
        };

        static Option<(string name, object value)> ContentProperty(string name, object value) =>
            Optional(value).Map(x => (name, x));

        static HttpContent MakeHttpContent(params Option<(string name, object value)>[] values) => ifNoneUnsafe(
            from body in Some(values.FoldT(HashMap<string, object>(), (acc, x) => acc.Add(x.name, x.value)))
            where !body.IsEmpty
            select new StringContent(SerializeObject(body, SerializerSettings)),
            () => null
        );

        HttpRequestMessage Request(HttpMethod method, string relativeUrl, params Option<(string name, object value)>[] values) =>
            new HttpRequestMessage(method, $"https://api.infusionsoft.com/crm/rest/v1/{relativeUrl}")
            {
                Content = MakeHttpContent(values)
            };

        EitherAsync<Error, KnownResponse> FindResponse(HttpResponseMessage message, HashSet<KnownResponse.Eq, KnownResponse> responses) => match(
            responses.Find(KnownResponse.For(message.StatusCode)),
            None: () => Left(new Error(message: $"Unexpected response: {message.StatusCode}")),
            Some: response => Right<Error, KnownResponse>(response)
        ).ToAsync();

        EitherAsync<Error, HttpResponseMessage> SendRequest(HttpRequestMessage message) => match(
            TryAsync(() => _client.SendAsync(message)),
            Fail: e => Left<Error, HttpResponseMessage>(new Error(message: $"Generic send error: {e.Message}")),
            Succ: x => Right<Error, HttpResponseMessage>(x)
        ).ToAsync();

        EitherAsync<Error, T> ReadResult<T>(HttpResponseMessage message, KnownResponse response)  where T : class =>
            !response.IsSuccess ?
            LeftAsync<Error, T>(new Error(message: response.Description).AsTask())
            : response.Type == typeof(Nothing)
                ? RightAsync<Error, T>((Nothing.Inst as T).AsTask())
                : match(
                    from json in TryAsync(message.Content.ReadAsStringAsync())
                    from result in Try(DeserializeObject(json, response.Type)).ToAsync()
                    select result,
                    Fail: e => Left<Error, T>(new Error(message: $"Generic read error: {e.Message}")),
                    Succ: t => match(
                        Optional((T) t),
                        None: () => Left<Error, T>(new Error(message: $"Unable to read {typeof(T)}")),
                        Some: x => Right<Error, T>(x)
                    )
                ).ToAsync();
    }

    public class KnownResponse : Record<KnownResponse>
    {
        public readonly int StatusCode;
        public readonly string Description;
        public readonly System.Type Type;
        public bool IsSuccess => (StatusCode >= 200) && (StatusCode <= 299);

        public KnownResponse(int statusCode, string description, System.Type type)
        {
            StatusCode = statusCode;
            Description = description;
            Type = type;
        }

        public static KnownResponse For(HttpStatusCode code) => new KnownResponse((int) code, "", null);

        public struct Eq : Eq<KnownResponse>
        {
            public bool Equals(KnownResponse x, KnownResponse y) => x.StatusCode.Equals(y.StatusCode);
            public int GetHashCode(KnownResponse x) => x.StatusCode.GetHashCode();
        }
    }

    public class Nothing
    {
        Nothing(){}
        public static Nothing Inst = new Nothing();
        public static implicit operator Unit(Nothing n) => unit;
    }
}