//----------------------
// <auto-generated>
// </auto-generated>
//----------------------
using System;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading.Tasks;

using Infusio.Model;
using LanguageExt;
using LanguageExt.TypeClasses;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;

// ReSharper disable RedundantStringInterpolation

namespace Infusio.Http
{
    using static Prelude;
    using static JsonConvert;

    public class InfusioClient
    {
        private readonly HttpClient _client;
        private readonly InfusioConfig _config;

        public InfusioClient(HttpClient client, InfusioConfig config)
        {
            _client = client;
            _config = config;
        }

        {% for op in Operations -%}
        /// <summary>
        /// {{ op.Summary }}
        /// </summary>
        {% for p in op.Parameters -%}
        /// <param name="{{ p.Name }}">{{ p.Description }}</param>
        {% endfor -%}
        public Task<Either<Error, {{ op.ResponseType | normalize }}>> {{ op.Name }}({% for p in op.Parameters %}{{ p.Type }} {{ p.Name }}{% if p.Required == false %} = default{% endif %}{% if forloop.last == false %}, {% endif %}{% endfor %}) =>
                    HttpWorkflow{% if op.ResponseType != 'Unit' %}<{{ op.ResponseType | normalize }}>{% endif %}(
                        message: Request({% if op.HttpMethod == 'Patch' %}
                                new HttpMethod("{{ op.HttpMethod }}"){% else %}HttpMethod.{{ op.HttpMethod }}{% endif -%},
                            MakeUri($"{{ op.Path }}"{% if op.HasQueryParameters %}, {% endif %}{% for p in op.QueryParameters %}
                                RequestParameter("{{ p.Name }}", {{ p.Name }}){% if forloop.last == false %}, {% endif %}{% endfor %}){% if op.HasRequestBodyParameters -%}, {% endif -%}
                        {% if op.HasSingleBodyParameter %}
                            {{ op.SingleBodyParameter.Name }}
                        {% else -%}
                        {% for p in op.RequestBodyParameters %}
                            RequestParameter("{{ p.Name }}", {{ p.Name }}){% if forloop.last == false %}, {% endif -%}
                        {% endfor -%}
                        {% endif -%}),
                        responses: HashSet<KnownResponse.Eq, KnownResponse>(
{% for res in op.Responses -%}
                            new KnownResponse({{ res.StatusCode }}, "{{ res.Description }}", typeof({{ res.Type | normalize }})){% if forloop.last == false %}, {% endif %}
{% endfor -%}
                    )).ToEither();

        /// <summary>
        /// {{ op.Summary }}
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="{{ op.Name }}"/>.</remarks>
        {% for p in op.Parameters -%}
        /// <param name="{{ p.Name }}">{{ p.Description }}</param>
        {% endfor -%}
        public Task<{{ op.ResponseType | normalize }}> {{ op.Name }}Unsafe({% for p in op.Parameters %}{{ p.Type }} {{ p.Name }}{% if p.Required == false %} = default{% endif %}{% if forloop.last == false %}, {% endif %}{% endfor %}) => {{ op.Name }}({% for p in op.Parameters -%}
            {{ p.Name }}{% if forloop.last == false %}, {% endif -%}{% endfor -%})
                    .ToAsync()
                    .IfLeftAsync(e => throw new Exception(e.Message));

        {% endfor -%}

        EitherAsync<Error, T> HttpWorkflow<T>(HttpRequestMessage message, HashSet<KnownResponse.Eq, KnownResponse> responses)  where T : class =>
            from httpResponse in SendRequest(message)
            from responseType in FindResponse(httpResponse, responses)
            from result in ReadResult<T>(httpResponse, responseType)
            select result;

        EitherAsync<Error, Unit> HttpWorkflow(HttpRequestMessage message, HashSet<KnownResponse.Eq, KnownResponse> responses) =>
            from httpResponse in SendRequest(message)
            from responseType in FindResponse(httpResponse, responses)
            select unit;

        static readonly JsonSerializerSettings SerializerSettings = new JsonSerializerSettings
        {
            NullValueHandling = NullValueHandling.Ignore,
            ContractResolver = new CamelCasePropertyNamesContractResolver()
        };

        static Option<(string name, object value)> RequestParameter(string name, object value) =>
            Optional(value).Map(x => (name, x));

        static HttpContent MakeHttpContent(params Option<(string name, object value)>[] values) => ifNoneUnsafe(
            from body in Some(values.FoldT(HashMap<string, object>(), (acc, x) => acc.Add(x.name, x.value)))
            where !body.IsEmpty
            select new StringContent(SerializeObject(body, SerializerSettings)),
            () => null
        );

        string MakeUri(string relative, params Option<(string name, object value)>[] values) => ifNone(
            from pair in Some(values.FoldT(HashMap<string, object>(), (acc, x) => acc.Add(x.name, x.value)))
            where !pair.IsEmpty
            select $"{relative}?{string.Join("&", pair.Map((key, value) => $"{key}={value}"))}",
            relative
        );

        HttpRequestMessage Request(HttpMethod method, string relativeUrl, params Option<(string name, object value)>[] values) =>
            Request(method, relativeUrl, MakeHttpContent(values));

        HttpRequestMessage Request(HttpMethod method, string relativeUrl, object body) =>
            Request(method, relativeUrl, new StringContent(SerializeObject(body), Encoding.UTF8, "application/json"));

        HttpRequestMessage Request(HttpMethod method, string relativeUrl, HttpContent content) =>
            new HttpRequestMessage(method, $"https://api.infusionsoft.com/crm/rest/v1/{relativeUrl}")
            {
                Content = content,
                Headers =
                {
                    Accept = { MediaTypeWithQualityHeaderValue.Parse("application/json")},
                    Authorization = new AuthenticationHeaderValue("Bearer", _config.ApiKey)
                }
            };

        EitherAsync<Error, KnownResponse> FindResponse(HttpResponseMessage message, HashSet<KnownResponse.Eq, KnownResponse> responses) => match(
            responses.Find(KnownResponse.For(message.StatusCode)),
            None: () => Left(new Error(message: $"Unexpected response: {message.StatusCode}")),
            Some: response => Right<Error, KnownResponse>(response)
        ).ToAsync();

        EitherAsync<Error, HttpResponseMessage> SendRequest(HttpRequestMessage message) => match(
            TryAsync(() => _client.SendAsync(message)),
            Fail: e => Left<Error, HttpResponseMessage>(new Error(message: $"Generic send error: {e.Message}")),
            Succ: x => Right<Error, HttpResponseMessage>(x)
        ).ToAsync();

        EitherAsync<Error, T> ReadResult<T>(HttpResponseMessage message, KnownResponse response) where T : class =>
            !response.IsSuccess ?
            Left<Error, T>(new Error(message: response.Description)).ToAsync()
            : match(
                    from json in TryAsync(message.Content.ReadAsStringAsync())
                    from result in Try(DeserializeObject(json, response.Type)).ToAsync()
                    select result,
                    Fail: e => Left<Error, T>(new Error(message: $"Generic read error: {e.Message}")),
                    Succ: t => match(
                        Optional((T)t),
                        None: () => Left<Error, T>(new Error(message: $"Unable to read {typeof(T)}")),
                        Some: x => Right<Error, T>(x)
                    )
                ).ToAsync();
    }

    public class KnownResponse : Record<KnownResponse>
    {
        public readonly int StatusCode;
        public readonly string Description;
        public readonly System.Type Type;
        public bool IsSuccess => (StatusCode >= 200) && (StatusCode <= 299);

        public KnownResponse(int statusCode, string description, System.Type type)
        {
            StatusCode = statusCode;
            Description = description;
            Type = type;
        }

        public static KnownResponse For(HttpStatusCode code) => new KnownResponse((int) code, "", null);

        public struct Eq : Eq<KnownResponse>
        {
            public bool Equals(KnownResponse x, KnownResponse y) => x.StatusCode.Equals(y.StatusCode);
            public int GetHashCode(KnownResponse x) => x.StatusCode.GetHashCode();
        }
    }
}