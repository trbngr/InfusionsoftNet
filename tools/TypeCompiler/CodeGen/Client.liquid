using System;
using System.Net.Http;
using System.Threading.Tasks;

using Infusion.Model;
using LanguageExt;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;

// ReSharper disable RedundantStringInterpolation

namespace Infusion
{
    using static Prelude;
    using static JsonConvert;

    public class InfusionClient
    {
        private readonly HttpClient _client;
        private readonly InfusionConfig _config;

        public InfusionClient(HttpClient client, InfusionConfig config)
        {
            _client = client;
            _config = config;
        }
        
        {% for op in Operations %}        
        /// <summary>
        /// {{ op.Summary }}
        /// </summary>
        {% for p in op.Parameters -%}
        /// <param name="{{ p.Name }}">{{ p.Description }}</param>
        {% endfor -%}
        public Task<{{ op.ResponseType | normalize }}> {{ op.Name }}({% for p in op.Parameters %}{{ p.Type }} {{ p.Name }}{% if p.Required == false %} = default{% endif %}{% if forloop.last == false %}, {% endif %}{% endfor %})
        {
            var message = new HttpRequestMessage(HttpMethod.{{ op.HttpMethod }}, $"{{ op.Path }}")
            {
                Content = MakeHttpContent(
                    {% for p in op.Parameters -%}
                    ContentProperty("{{ p.Name }}", {{ p.Name }}){% if forloop.last == false %}, {% endif %}
                    {% endfor -%}
                )
            };
            return default({{ op.ResponseType | normalize }}).AsTask();
        }
        {% endfor -%}

        static readonly JsonSerializerSettings SerializerSettings = new JsonSerializerSettings
        {
            NullValueHandling = NullValueHandling.Ignore,
            ContractResolver = new CamelCasePropertyNamesContractResolver()
        };

        static Option<(string name, object value)> ContentProperty(string name, object value) =>
            Optional(value).Map(x => (name, x));

        static HttpContent MakeHttpContent(params Option<(string name, object value)>[] values) => ifNoneUnsafe(
            from map1 in Some(values.FoldT(HashMap<string, object>(), (acc, x) => acc.Add(x.name, x.value)))
            where !map1.IsEmpty
            select new StringContent(SerializeObject(
                map1,
                SerializerSettings
            )),
            () => null
        );

        EitherAsync<Error, T> Send<T>(HttpRequestMessage message) =>
            from response in TryAsync(_client.SendAsync(message))
            from end in response.IsSuccessStatusCode
                ? ReadResult<T>(response)
                : ReadError(response).Bind(e => TryAsync<T>(() => throw new Exception(e.Message)))
            select end;

        TryAsync<T> ReadResult<T>(HttpResponseMessage response) =>
            from json in TryAsync(response.Content.ReadAsStringAsync())
            from result in Try(DeserializeObject<T>(json)).ToAsync()
            select result;

        TryAsync<Error> ReadError(HttpResponseMessage response) =>
            from json in TryAsync(response.Content.ReadAsStringAsync())
            from result in Try(DeserializeObject<Error>(json)).ToAsync()
            select result;


    }
}