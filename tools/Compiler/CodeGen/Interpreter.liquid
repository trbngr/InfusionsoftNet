using System;
using System.Threading.Tasks;
using LanguageExt;
using Newtonsoft.Json;

namespace Infusio.Http
{
    using static Prelude;
    using static Formatting;
    using static JsonConvert;

    public static class HttpSupport
    {
        public static Task<Either<InfusioError, InfusioResult<T>>> interpret<T>(InfusioOp<T> op, InfusioClient client) =>
            RunWith(op, InterpreterState.Empty, client);

        public static Task<Either<InfusioError, InfusioResult<T>>> RunWith<T>(this InfusioOp<T> op, InfusioClient client) =>
            RunWith(op, InterpreterState.Empty, client);

        public static Task<Either<InfusioError, InfusioResult<T>>> interpret<T>(InfusioOp<T> op, InterpreterState state, InfusioClient client) =>
            RunAsync(op, state, client).ToEither();

        public static Task<Either<InfusioError, InfusioResult<T>>> RunWith<T>(this InfusioOp<T> op, InterpreterState state, InfusioClient client) =>
            RunAsync(op, state, client).ToEither();

        static EitherAsync<InfusioError, InfusioResult<T>> RunAsync<T>(InfusioOp<T> op, InterpreterState state, InfusioClient client) =>
            op is InfusioOp<T>.Return r ? Right<InfusioError, InfusioResult<T>>(new InfusioResult<T>(r.Value, state.Logs)).ToAsync() :
            op is InfusioOp<T>.Log l ? Right<InfusioError, InfusioResult<T>>(new InfusioResult<T>(default, state.Log(l.Message).Logs)).ToAsync() :
{% for op in Operations -%}
            op is InfusioOp<T>.{{ op.Name }}{% assign op_name = forloop.index %} _{{ op_name }} ? Exe(op.ToString(), () => client.{{ op.Name }}({% for p in op.Parameters -%}_{{ op_name }}.{{ p.Name | capitalize }}{% if forloop.last == false %}, {% endif %}{% endfor %}), _{{ op_name }}.Next, state, client) :
{% endfor -%}
            throw new NotSupportedException();

        static EitherAsync<InfusioError, InfusioResult<B>> Exe<T, B>(string describe, Func<Task<Either<InfusioError, T>>> fn, Func<T, InfusioOp<B>> nextOp, InterpreterState state, InfusioClient client) =>
            from right in LogOperation(describe, state, fn).ToAsync()
            from next in RunAsync(nextOp(right.Value), right.State, client)
            select next;

        static Task<Either<InfusioError, (InterpreterState State, T Value)>> LogOperation<T>(string describe, InterpreterState state, Func<Task<Either<InfusioError, T>>> fn) =>
            from st in Right<InfusioError, (InterpreterState, Unit)>((state.Log(describe), unit)).AsTask()
            from result in fn().ToAsync().Match(
                Left: error => Left<InfusioError, (InterpreterState, T)>(error),
                Right: value => Right<InfusioError, (InterpreterState, T)>((st.Item1.Log($" -> {SerializeObject(value, Indented)}"), value))
            )
            select result;
    }

    public class InterpreterState
    {
        public static readonly InterpreterState Empty = new InterpreterState(Seq<string>());
        public readonly Seq<string> Logs;

        public InterpreterState(Seq<string> logs) =>
            Logs = logs;

        public InterpreterState Log(string message) =>
            new InterpreterState(Logs.Append(Seq1(message)));
    }
}