//----------------------
// <auto-generated>
// </auto-generated>
//----------------------
using System;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading.Tasks;

using Infusio.Model;
using LanguageExt;
using LanguageExt.TypeClasses;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;

// ReSharper disable RedundantStringInterpolation

namespace Infusio.Http
{
    using static Prelude;
    using static JsonConvert;

    public class InfusioClient
    {
        private readonly HttpClient _client;
        private readonly InfusioConfig _config;

        public InfusioClient(HttpClient client, InfusioConfig config)
        {
            _client = client;
            _config = config;
        }

        /// <summary>
        /// Retrieve account profile
        /// </summary>
        public Task<Either<InfusioError, AccountProfile>> GetAccountProfile() =>
            HttpWorkflow<AccountProfile>(
                Request(HttpMethod.Get,
                    MakeUri($"/account/profile")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(AccountProfile)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve account profile
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetAccountProfile"/>.</remarks>
        public Task<AccountProfile> GetAccountProfileUnsafe() => GetAccountProfile()
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Updates an account profile
        /// </summary>
        /// <param name="accountInfo">accountInfo</param>
        public Task<Either<InfusioError, AccountProfile>> UpdateAccountInfo(AccountProfile accountInfo) =>
            HttpWorkflow<AccountProfile>(
                Request(HttpMethod.Put,
                    MakeUri($"/account/profile"),
                    accountInfo
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(AccountProfile)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Updates an account profile
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="UpdateAccountInfo"/>.</remarks>
        /// <param name="accountInfo">accountInfo</param>
        public Task<AccountProfile> UpdateAccountInfoUnsafe(AccountProfile accountInfo) => UpdateAccountInfo(accountInfo)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve Commissions
        /// </summary>
        /// <param name="affiliateId">Affiliate to retrieve commissions for</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<Either<InfusioError, AffiliateCommissionList>> SearchCommissions(long? affiliateId = default, int? offset = default, int? limit = default, string until = default, string since = default) =>
            HttpWorkflow<AffiliateCommissionList>(
                Request(HttpMethod.Get,
                    MakeUri($"/affiliates/commissions",
                        RequestParameter("affiliateId", affiliateId),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit),
                        RequestParameter("until", until),
                        RequestParameter("since", since))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(AffiliateCommissionList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve Commissions
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="SearchCommissions"/>.</remarks>
        /// <param name="affiliateId">Affiliate to retrieve commissions for</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<AffiliateCommissionList> SearchCommissionsUnsafe(long affiliateId = default, int offset = default, int limit = default, string until = default, string since = default) => SearchCommissions(affiliateId, offset, limit, until, since)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve Affiliate Model
        /// </summary>
        public Task<Either<InfusioError, ObjectModel>> RetrieveAffiliateModel() =>
            HttpWorkflow<ObjectModel>(
                Request(HttpMethod.Get,
                    MakeUri($"/affiliates/model")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(ObjectModel)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve Affiliate Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveAffiliateModel"/>.</remarks>
        public Task<ObjectModel> RetrieveAffiliateModelUnsafe() => RetrieveAffiliateModel()
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Appointments
        /// </summary>
        /// <param name="contactId">Optionally find appointments with a contact</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<Either<InfusioError, AppointmentList>> ListAppointments(long? contactId = default, int? offset = default, int? limit = default, string until = default, string since = default) =>
            HttpWorkflow<AppointmentList>(
                Request(HttpMethod.Get,
                    MakeUri($"/appointments",
                        RequestParameter("contactId", contactId),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit),
                        RequestParameter("until", until),
                        RequestParameter("since", since))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(AppointmentList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Appointments
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListAppointments"/>.</remarks>
        /// <param name="contactId">Optionally find appointments with a contact</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<AppointmentList> ListAppointmentsUnsafe(long contactId = default, int offset = default, int limit = default, string until = default, string since = default) => ListAppointments(contactId, offset, limit, until, since)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Create an Appointment
        /// </summary>
        /// <param name="appointment">appointment</param>
        public Task<Either<InfusioError, Appointment>> CreateAppointment(Model.Appointment appointment) =>
            HttpWorkflow<Appointment>(
                Request(HttpMethod.Post,
                    MakeUri($"/appointments"),
                    appointment
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(201, "Created", typeof(Appointment)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Create an Appointment
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateAppointment"/>.</remarks>
        /// <param name="appointment">appointment</param>
        public Task<Appointment> CreateAppointmentUnsafe(Model.Appointment appointment) => CreateAppointment(appointment)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve Appointment Model
        /// </summary>
        public Task<Either<InfusioError, ObjectModel>> RetrieveAppointmentModel() =>
            HttpWorkflow<ObjectModel>(
                Request(HttpMethod.Get,
                    MakeUri($"/appointments/model")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(ObjectModel)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve Appointment Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveAppointmentModel"/>.</remarks>
        public Task<ObjectModel> RetrieveAppointmentModelUnsafe() => RetrieveAppointmentModel()
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve an Appointment
        /// </summary>
        /// <param name="appointmentId">appointmentId</param>
        public Task<Either<InfusioError, Appointment>> GetAppointment(long? appointmentId) =>
            HttpWorkflow<Appointment>(
                Request(HttpMethod.Get,
                    MakeUri($"/appointments/{appointmentId}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Appointment)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve an Appointment
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetAppointment"/>.</remarks>
        /// <param name="appointmentId">appointmentId</param>
        public Task<Appointment> GetAppointmentUnsafe(long appointmentId) => GetAppointment(appointmentId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Replace an Appointment
        /// </summary>
        /// <param name="appointmentDTO">appointmentDTO</param>
        /// <param name="appointmentId">appointmentId</param>
        public Task<Either<InfusioError, Appointment>> UpdateAppointment(Model.Appointment appointmentDTO, long? appointmentId) =>
            HttpWorkflow<Appointment>(
                Request(HttpMethod.Put,
                    MakeUri($"/appointments/{appointmentId}"),
                    appointmentDTO
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Appointment)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Replace an Appointment
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="UpdateAppointment"/>.</remarks>
        /// <param name="appointmentDTO">appointmentDTO</param>
        /// <param name="appointmentId">appointmentId</param>
        public Task<Appointment> UpdateAppointmentUnsafe(Model.Appointment appointmentDTO, long appointmentId) => UpdateAppointment(appointmentDTO, appointmentId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Delete an Appointment
        /// </summary>
        /// <param name="appointmentId">appointmentId</param>
        public Task<Either<InfusioError, Unit>> DeleteAppointment(long? appointmentId) =>
            HttpWorkflow(
                Request(HttpMethod.Delete,
                    MakeUri($"/appointments/{appointmentId}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(204, "No Content", typeof(Unit)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Delete an Appointment
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="DeleteAppointment"/>.</remarks>
        /// <param name="appointmentId">appointmentId</param>
        public Task<Unit> DeleteAppointmentUnsafe(long appointmentId) => DeleteAppointment(appointmentId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Update an Appointment
        /// </summary>
        /// <param name="appointmentDTO">appointmentDTO</param>
        /// <param name="appointmentId">appointmentId</param>
        public Task<Either<InfusioError, Appointment>> UpdatePropertiesOnAppointment(Model.Appointment appointmentDTO, long? appointmentId) =>
            HttpWorkflow<Appointment>(
                Request(
                        new HttpMethod("Patch"),
                    MakeUri($"/appointments/{appointmentId}"),
                    appointmentDTO
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Appointment)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Update an Appointment
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="UpdatePropertiesOnAppointment"/>.</remarks>
        /// <param name="appointmentDTO">appointmentDTO</param>
        /// <param name="appointmentId">appointmentId</param>
        public Task<Appointment> UpdatePropertiesOnAppointmentUnsafe(Model.Appointment appointmentDTO, long appointmentId) => UpdatePropertiesOnAppointment(appointmentDTO, appointmentId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Campaigns
        /// </summary>
        /// <param name="orderDirection">How to order the data i.e. ascending (A-Z) or descending (Z-A)</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="searchText">Optional text to search</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<InfusioError, CampaignList>> ListCampaigns(string orderDirection = default, string order = default, string searchText = default, int? offset = default, int? limit = default) =>
            HttpWorkflow<CampaignList>(
                Request(HttpMethod.Get,
                    MakeUri($"/campaigns",
                        RequestParameter("orderDirection", orderDirection),
                        RequestParameter("order", order),
                        RequestParameter("searchText", searchText),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(CampaignList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Campaigns
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListCampaigns"/>.</remarks>
        /// <param name="orderDirection">How to order the data i.e. ascending (A-Z) or descending (Z-A)</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="searchText">Optional text to search</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<CampaignList> ListCampaignsUnsafe(string orderDirection = default, string order = default, string searchText = default, int offset = default, int limit = default) => ListCampaigns(orderDirection, order, searchText, offset, limit)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve a Campaign
        /// </summary>
        /// <param name="campaignId">campaignId</param>
        /// <param name="optionalProperties">Comma-delimited list of Campaign properties to include in the response. (The fields `goals` and `sequences` aren't included, by default.)</param>
        public Task<Either<InfusioError, Campaign>> GetCampaign(long? campaignId, Lst<string> optionalProperties = default) =>
            HttpWorkflow<Campaign>(
                Request(HttpMethod.Get,
                    MakeUri($"/campaigns/{campaignId}",
                        RequestParameter("optionalProperties", optionalProperties))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Campaign)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve a Campaign
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetCampaign"/>.</remarks>
        /// <param name="campaignId">campaignId</param>
        /// <param name="optionalProperties">Comma-delimited list of Campaign properties to include in the response. (The fields `goals` and `sequences` aren't included, by default.)</param>
        public Task<Campaign> GetCampaignUnsafe(long campaignId, Lst<string> optionalProperties = default) => GetCampaign(campaignId, optionalProperties)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Add Multiple to Campaign Sequence
        /// </summary>
        /// <param name="ids">ids</param>
        /// <param name="sequenceId">sequenceId</param>
        /// <param name="campaignId">campaignId</param>
        public Task<Either<InfusioError, Unit>> AddContactsToCampaignSequence(Model.SetOfIds ids, long? sequenceId, long? campaignId) =>
            HttpWorkflow(
                Request(HttpMethod.Post,
                    MakeUri($"/campaigns/{campaignId}/sequences/{sequenceId}/contacts"),
                    ids
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(204, "No Content", typeof(Unit)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Add Multiple to Campaign Sequence
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="AddContactsToCampaignSequence"/>.</remarks>
        /// <param name="ids">ids</param>
        /// <param name="sequenceId">sequenceId</param>
        /// <param name="campaignId">campaignId</param>
        public Task<Unit> AddContactsToCampaignSequenceUnsafe(Model.SetOfIds ids, long sequenceId, long campaignId) => AddContactsToCampaignSequence(ids, sequenceId, campaignId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Remove Multiple from Campaign Sequence
        /// </summary>
        /// <param name="ids">ids</param>
        /// <param name="sequenceId">sequenceId</param>
        /// <param name="campaignId">campaignId</param>
        public Task<Either<InfusioError, Unit>> RemoveContactsFromCampaignSequence(Model.SetOfIds ids, long? sequenceId, long? campaignId) =>
            HttpWorkflow(
                Request(HttpMethod.Delete,
                    MakeUri($"/campaigns/{campaignId}/sequences/{sequenceId}/contacts"),
                    ids
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(204, "No Content", typeof(Unit)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Remove Multiple from Campaign Sequence
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RemoveContactsFromCampaignSequence"/>.</remarks>
        /// <param name="ids">ids</param>
        /// <param name="sequenceId">sequenceId</param>
        /// <param name="campaignId">campaignId</param>
        public Task<Unit> RemoveContactsFromCampaignSequenceUnsafe(Model.SetOfIds ids, long sequenceId, long campaignId) => RemoveContactsFromCampaignSequence(ids, sequenceId, campaignId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Add to Campaign Sequence
        /// </summary>
        /// <param name="contactId">contactId</param>
        /// <param name="sequenceId">sequenceId</param>
        /// <param name="campaignId">campaignId</param>
        public Task<Either<InfusioError, Unit>> AddContactToCampaignSequence(long? contactId, long? sequenceId, long? campaignId) =>
            HttpWorkflow(
                Request(HttpMethod.Post,
                    MakeUri($"/campaigns/{campaignId}/sequences/{sequenceId}/contacts/{contactId}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(204, "No Content", typeof(Unit)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Add to Campaign Sequence
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="AddContactToCampaignSequence"/>.</remarks>
        /// <param name="contactId">contactId</param>
        /// <param name="sequenceId">sequenceId</param>
        /// <param name="campaignId">campaignId</param>
        public Task<Unit> AddContactToCampaignSequenceUnsafe(long contactId, long sequenceId, long campaignId) => AddContactToCampaignSequence(contactId, sequenceId, campaignId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Remove from Campaign Sequence
        /// </summary>
        /// <param name="contactId">contactId</param>
        /// <param name="sequenceId">sequenceId</param>
        /// <param name="campaignId">campaignId</param>
        public Task<Either<InfusioError, Unit>> RemoveContactFromCampaignSequence(long? contactId, long? sequenceId, long? campaignId) =>
            HttpWorkflow(
                Request(HttpMethod.Delete,
                    MakeUri($"/campaigns/{campaignId}/sequences/{sequenceId}/contacts/{contactId}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(204, "No Content", typeof(Unit)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Remove from Campaign Sequence
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RemoveContactFromCampaignSequence"/>.</remarks>
        /// <param name="contactId">contactId</param>
        /// <param name="sequenceId">sequenceId</param>
        /// <param name="campaignId">campaignId</param>
        public Task<Unit> RemoveContactFromCampaignSequenceUnsafe(long contactId, long sequenceId, long campaignId) => RemoveContactFromCampaignSequence(contactId, sequenceId, campaignId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Companies
        /// </summary>
        /// <param name="optionalProperties">Comma-delimited list of Company properties to include in the response. (Fields such as `notes`, `fax_number` and `custom_fields` aren't included, by default.)</param>
        /// <param name="orderDirection">How to order the data i.e. ascending (A-Z) or descending (Z-A)</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="companyName">Optional company name to query on</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<InfusioError, CompanyList>> ListCompanies(Lst<string> optionalProperties = default, string orderDirection = default, string order = default, string companyName = default, int? offset = default, int? limit = default) =>
            HttpWorkflow<CompanyList>(
                Request(HttpMethod.Get,
                    MakeUri($"/companies",
                        RequestParameter("optionalProperties", optionalProperties),
                        RequestParameter("orderDirection", orderDirection),
                        RequestParameter("order", order),
                        RequestParameter("companyName", companyName),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(CompanyList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Companies
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListCompanies"/>.</remarks>
        /// <param name="optionalProperties">Comma-delimited list of Company properties to include in the response. (Fields such as `notes`, `fax_number` and `custom_fields` aren't included, by default.)</param>
        /// <param name="orderDirection">How to order the data i.e. ascending (A-Z) or descending (Z-A)</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="companyName">Optional company name to query on</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<CompanyList> ListCompaniesUnsafe(Lst<string> optionalProperties = default, string orderDirection = default, string order = default, string companyName = default, int offset = default, int limit = default) => ListCompanies(optionalProperties, orderDirection, order, companyName, offset, limit)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Create a Company
        /// </summary>
        /// <param name="company">company</param>
        public Task<Either<InfusioError, Company>> CreateCompany(Model.CreateCompany company = default) =>
            HttpWorkflow<Company>(
                Request(HttpMethod.Post,
                    MakeUri($"/companies"),
                    company
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(201, "Created", typeof(Company)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Create a Company
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateCompany"/>.</remarks>
        /// <param name="company">company</param>
        public Task<Company> CreateCompanyUnsafe(Model.CreateCompany company = default) => CreateCompany(company)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve Company Model
        /// </summary>
        public Task<Either<InfusioError, ObjectModel>> RetrieveCompanyModel() =>
            HttpWorkflow<ObjectModel>(
                Request(HttpMethod.Get,
                    MakeUri($"/companies/model")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(ObjectModel)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve Company Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveCompanyModel"/>.</remarks>
        public Task<ObjectModel> RetrieveCompanyModelUnsafe() => RetrieveCompanyModel()
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Contacts
        /// </summary>
        /// <param name="orderDirection">How to order the data i.e. ascending (A-Z) or descending (Z-A)</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="familyName">Optional last name or surname to query on</param>
        /// <param name="givenName">Optional first name or forename to query on</param>
        /// <param name="email">Optional email address to query on</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<InfusioError, ContactList>> ListContacts(string orderDirection = default, string order = default, string familyName = default, string givenName = default, string email = default, int? offset = default, int? limit = default) =>
            HttpWorkflow<ContactList>(
                Request(HttpMethod.Get,
                    MakeUri($"/contacts",
                        RequestParameter("orderDirection", orderDirection),
                        RequestParameter("order", order),
                        RequestParameter("familyName", familyName),
                        RequestParameter("givenName", givenName),
                        RequestParameter("email", email),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(ContactList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Contacts
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListContacts"/>.</remarks>
        /// <param name="orderDirection">How to order the data i.e. ascending (A-Z) or descending (Z-A)</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="familyName">Optional last name or surname to query on</param>
        /// <param name="givenName">Optional first name or forename to query on</param>
        /// <param name="email">Optional email address to query on</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<ContactList> ListContactsUnsafe(string orderDirection = default, string order = default, string familyName = default, string givenName = default, string email = default, int offset = default, int limit = default) => ListContacts(orderDirection, order, familyName, givenName, email, offset, limit)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Create a Contact
        /// </summary>
        /// <param name="contact">contact</param>
        public Task<Either<InfusioError, FullContact>> CreateContact(Model.RequestContact contact = default) =>
            HttpWorkflow<FullContact>(
                Request(HttpMethod.Post,
                    MakeUri($"/contacts"),
                    contact
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(201, "Created", typeof(FullContact)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Create a Contact
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateContact"/>.</remarks>
        /// <param name="contact">contact</param>
        public Task<FullContact> CreateContactUnsafe(Model.RequestContact contact = default) => CreateContact(contact)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Create or Update a Contact
        /// </summary>
        /// <param name="contact">contact</param>
        public Task<Either<InfusioError, FullContact>> CreateOrUpdateContact(Model.UpsertContact contact = default) =>
            HttpWorkflow<FullContact>(
                Request(HttpMethod.Put,
                    MakeUri($"/contacts"),
                    contact
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(FullContact)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Create or Update a Contact
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateOrUpdateContact"/>.</remarks>
        /// <param name="contact">contact</param>
        public Task<FullContact> CreateOrUpdateContactUnsafe(Model.UpsertContact contact = default) => CreateOrUpdateContact(contact)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve Contact Model
        /// </summary>
        public Task<Either<InfusioError, ObjectModel>> RetrieveContactModel() =>
            HttpWorkflow<ObjectModel>(
                Request(HttpMethod.Get,
                    MakeUri($"/contacts/model")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(ObjectModel)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve Contact Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveContactModel"/>.</remarks>
        public Task<ObjectModel> RetrieveContactModelUnsafe() => RetrieveContactModel()
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Delete a Contact
        /// </summary>
        /// <param name="contactId">contactId</param>
        public Task<Either<InfusioError, Unit>> DeleteContact(long? contactId) =>
            HttpWorkflow(
                Request(HttpMethod.Delete,
                    MakeUri($"/contacts/{contactId}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(204, "No Content", typeof(Unit)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Delete a Contact
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="DeleteContact"/>.</remarks>
        /// <param name="contactId">contactId</param>
        public Task<Unit> DeleteContactUnsafe(long contactId) => DeleteContact(contactId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Update a Contact
        /// </summary>
        /// <param name="contactId">contactId</param>
        /// <param name="contact">contact</param>
        public Task<Either<InfusioError, FullContact>> UpdatePropertiesOnContact(long? contactId, Model.RequestContact contact = default) =>
            HttpWorkflow<FullContact>(
                Request(
                        new HttpMethod("Patch"),
                    MakeUri($"/contacts/{contactId}"),
                    contact
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(FullContact)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Update a Contact
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="UpdatePropertiesOnContact"/>.</remarks>
        /// <param name="contactId">contactId</param>
        /// <param name="contact">contact</param>
        public Task<FullContact> UpdatePropertiesOnContactUnsafe(long contactId, Model.RequestContact contact = default) => UpdatePropertiesOnContact(contactId, contact)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Create a Credit Card
        /// </summary>
        /// <param name="contactId">contactId</param>
        /// <param name="creditCard">creditCard</param>
        public Task<Either<InfusioError, CreditCardAdded>> CreateCreditCard(long? contactId, Model.CreditCard creditCard = default) =>
            HttpWorkflow<CreditCardAdded>(
                Request(HttpMethod.Post,
                    MakeUri($"/contacts/{contactId}/creditCards"),
                    creditCard
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(201, "Created", typeof(CreditCardAdded)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Create a Credit Card
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateCreditCard"/>.</remarks>
        /// <param name="contactId">contactId</param>
        /// <param name="creditCard">creditCard</param>
        public Task<CreditCardAdded> CreateCreditCardUnsafe(long contactId, Model.CreditCard creditCard = default) => CreateCreditCard(contactId, creditCard)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Emails
        /// </summary>
        /// <param name="contactId">contactId</param>
        /// <param name="email">Optional email address to query on</param>
        /// <param name="contactId2">Optional Contact Id to find Emails for</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<InfusioError, EmailSentQueryResultList>> ListEmailsForContact(long? contactId, string email = default, long? contactId2 = default, int? offset = default, int? limit = default) =>
            HttpWorkflow<EmailSentQueryResultList>(
                Request(HttpMethod.Get,
                    MakeUri($"/contacts/{contactId}/emails",
                        RequestParameter("email", email),
                        RequestParameter("contactId2", contactId2),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(EmailSentQueryResultList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Emails
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListEmailsForContact"/>.</remarks>
        /// <param name="contactId">contactId</param>
        /// <param name="email">Optional email address to query on</param>
        /// <param name="contactId2">Optional Contact Id to find Emails for</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<EmailSentQueryResultList> ListEmailsForContactUnsafe(long contactId, string email = default, long contactId2 = default, int offset = default, int limit = default) => ListEmailsForContact(contactId, email, contactId2, offset, limit)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Create an Email Record
        /// </summary>
        /// <param name="contactId">contactId</param>
        /// <param name="emailWithContent">Email records to persist, with content.</param>
        public Task<Either<InfusioError, EmailSentCreate>> CreateEmailForContact(long? contactId, Model.EmailSentCreate emailWithContent = default) =>
            HttpWorkflow<EmailSentCreate>(
                Request(HttpMethod.Post,
                    MakeUri($"/contacts/{contactId}/emails"),
                    emailWithContent
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(201, "Created", typeof(EmailSentCreate)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Create an Email Record
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateEmailForContact"/>.</remarks>
        /// <param name="contactId">contactId</param>
        /// <param name="emailWithContent">Email records to persist, with content.</param>
        public Task<EmailSentCreate> CreateEmailForContactUnsafe(long contactId, Model.EmailSentCreate emailWithContent = default) => CreateEmailForContact(contactId, emailWithContent)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Applied Tags
        /// </summary>
        /// <param name="contactId">contactId</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<InfusioError, ContactTagList>> ListAppliedTags(long? contactId, int? offset = default, int? limit = default) =>
            HttpWorkflow<ContactTagList>(
                Request(HttpMethod.Get,
                    MakeUri($"/contacts/{contactId}/tags",
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(ContactTagList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Applied Tags
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListAppliedTags"/>.</remarks>
        /// <param name="contactId">contactId</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<ContactTagList> ListAppliedTagsUnsafe(long contactId, int offset = default, int limit = default) => ListAppliedTags(contactId, offset, limit)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Apply Tags
        /// </summary>
        /// <param name="tagIds">tagIds</param>
        /// <param name="contactId">contactId</param>
        public Task<Either<InfusioError, Unit>> ApplyTagsToContactId(Model.TagId tagIds, long? contactId) =>
            HttpWorkflow(
                Request(HttpMethod.Post,
                    MakeUri($"/contacts/{contactId}/tags"),
                    tagIds
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Unit)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Apply Tags
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ApplyTagsToContactId"/>.</remarks>
        /// <param name="tagIds">tagIds</param>
        /// <param name="contactId">contactId</param>
        public Task<Unit> ApplyTagsToContactIdUnsafe(Model.TagId tagIds, long contactId) => ApplyTagsToContactId(tagIds, contactId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Remove Applied Tags
        /// </summary>
        /// <param name="ids">ids</param>
        /// <param name="contactId">contactId</param>
        public Task<Either<InfusioError, Unit>> RemoveTagsFromContact(string ids, long? contactId) =>
            HttpWorkflow(
                Request(HttpMethod.Delete,
                    MakeUri($"/contacts/{contactId}/tags",
                        RequestParameter("ids", ids))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(204, "No Content", typeof(Unit)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Remove Applied Tags
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RemoveTagsFromContact"/>.</remarks>
        /// <param name="ids">ids</param>
        /// <param name="contactId">contactId</param>
        public Task<Unit> RemoveTagsFromContactUnsafe(string ids, long contactId) => RemoveTagsFromContact(ids, contactId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Remove Applied Tag
        /// </summary>
        /// <param name="tagId">tagId</param>
        /// <param name="contactId">contactId</param>
        public Task<Either<InfusioError, Unit>> RemoveTagsFromContact2(long? tagId, long? contactId) =>
            HttpWorkflow(
                Request(HttpMethod.Delete,
                    MakeUri($"/contacts/{contactId}/tags/{tagId}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(204, "No Content", typeof(Unit)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Remove Applied Tag
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RemoveTagsFromContact2"/>.</remarks>
        /// <param name="tagId">tagId</param>
        /// <param name="contactId">contactId</param>
        public Task<Unit> RemoveTagsFromContact2Unsafe(long tagId, long contactId) => RemoveTagsFromContact2(tagId, contactId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve a Contact
        /// </summary>
        /// <param name="id">id</param>
        /// <param name="optionalProperties">Comma-delimited list of Contact properties to include in the response. (Some fields such as `lead_source_id`, `custom_fields`, and `job_title` aren't included, by default.)</param>
        public Task<Either<InfusioError, FullContact>> GetContact(long? id, Lst<string> optionalProperties = default) =>
            HttpWorkflow<FullContact>(
                Request(HttpMethod.Get,
                    MakeUri($"/contacts/{id}",
                        RequestParameter("optionalProperties", optionalProperties))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(FullContact)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve a Contact
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetContact"/>.</remarks>
        /// <param name="id">id</param>
        /// <param name="optionalProperties">Comma-delimited list of Contact properties to include in the response. (Some fields such as `lead_source_id`, `custom_fields`, and `job_title` aren't included, by default.)</param>
        public Task<FullContact> GetContactUnsafe(long id, Lst<string> optionalProperties = default) => GetContact(id, optionalProperties)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Emails
        /// </summary>
        /// <param name="email">Optional email address to query on</param>
        /// <param name="contactId">Optional Contact Id to find Emails for</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<InfusioError, EmailSentQueryResultList>> ListEmails(string email = default, long? contactId = default, int? offset = default, int? limit = default) =>
            HttpWorkflow<EmailSentQueryResultList>(
                Request(HttpMethod.Get,
                    MakeUri($"/emails",
                        RequestParameter("email", email),
                        RequestParameter("contactId", contactId),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(EmailSentQueryResultList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Emails
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListEmails"/>.</remarks>
        /// <param name="email">Optional email address to query on</param>
        /// <param name="contactId">Optional Contact Id to find Emails for</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<EmailSentQueryResultList> ListEmailsUnsafe(string email = default, long contactId = default, int offset = default, int limit = default) => ListEmails(email, contactId, offset, limit)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Create an Email Record
        /// </summary>
        /// <param name="emailWithContent">Email records to persist, with content.</param>
        public Task<Either<InfusioError, EmailSentCreate>> CreateEmail(Model.EmailSentCreate emailWithContent = default) =>
            HttpWorkflow<EmailSentCreate>(
                Request(HttpMethod.Post,
                    MakeUri($"/emails"),
                    emailWithContent
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(201, "Created", typeof(EmailSentCreate)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Create an Email Record
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateEmail"/>.</remarks>
        /// <param name="emailWithContent">Email records to persist, with content.</param>
        public Task<EmailSentCreate> CreateEmailUnsafe(Model.EmailSentCreate emailWithContent = default) => CreateEmail(emailWithContent)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Create a set of Email Records
        /// </summary>
        /// <param name="emailWithContent">Email records to persist, with content.</param>
        public Task<Either<InfusioError, EmailSentCreateList>> CreateEmails(Model.EmailSentCreateList emailWithContent = default) =>
            HttpWorkflow<EmailSentCreateList>(
                Request(HttpMethod.Post,
                    MakeUri($"/emails/sync"),
                    emailWithContent
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(201, "Created", typeof(EmailSentCreateList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Create a set of Email Records
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateEmails"/>.</remarks>
        /// <param name="emailWithContent">Email records to persist, with content.</param>
        public Task<EmailSentCreateList> CreateEmailsUnsafe(Model.EmailSentCreateList emailWithContent = default) => CreateEmails(emailWithContent)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Un-sync a batch of Email Records
        /// </summary>
        /// <param name="emailIds">emailIds</param>
        public Task<Either<InfusioError, Unit>> DeleteEmails(Model.SetOfIds emailIds) =>
            HttpWorkflow(
                Request(HttpMethod.Post,
                    MakeUri($"/emails/unsync"),
                    emailIds
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Unit)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Un-sync a batch of Email Records
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="DeleteEmails"/>.</remarks>
        /// <param name="emailIds">emailIds</param>
        public Task<Unit> DeleteEmailsUnsafe(Model.SetOfIds emailIds) => DeleteEmails(emailIds)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve an Email
        /// </summary>
        /// <param name="id">id</param>
        public Task<Either<InfusioError, EmailSentQueryResultWithContent>> GetEmail(long? id) =>
            HttpWorkflow<EmailSentQueryResultWithContent>(
                Request(HttpMethod.Get,
                    MakeUri($"/emails/{id}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(EmailSentQueryResultWithContent)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve an Email
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetEmail"/>.</remarks>
        /// <param name="id">id</param>
        public Task<EmailSentQueryResultWithContent> GetEmailUnsafe(long id) => GetEmail(id)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Update an Email Record
        /// </summary>
        /// <param name="id">id</param>
        /// <param name="emailWithContent">Email records to persist, with content.</param>
        public Task<Either<InfusioError, EmailSentCreate>> UpdateEmail(long? id, Model.EmailSentCreate emailWithContent = default) =>
            HttpWorkflow<EmailSentCreate>(
                Request(HttpMethod.Put,
                    MakeUri($"/emails/{id}"),
                    emailWithContent
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(EmailSentCreate)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Update an Email Record
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="UpdateEmail"/>.</remarks>
        /// <param name="id">id</param>
        /// <param name="emailWithContent">Email records to persist, with content.</param>
        public Task<EmailSentCreate> UpdateEmailUnsafe(long id, Model.EmailSentCreate emailWithContent = default) => UpdateEmail(id, emailWithContent)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Delete an Email Record
        /// </summary>
        /// <param name="id">id</param>
        public Task<Either<InfusioError, Unit>> DeleteEmail(long? id) =>
            HttpWorkflow(
                Request(HttpMethod.Delete,
                    MakeUri($"/emails/{id}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(204, "No Content", typeof(Unit)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Delete an Email Record
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="DeleteEmail"/>.</remarks>
        /// <param name="id">id</param>
        public Task<Unit> DeleteEmailUnsafe(long id) => DeleteEmail(id)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Files
        /// </summary>
        /// <param name="name">Filter files based on name, with '*' preceding or following to indicate LIKE queries.</param>
        /// <param name="type">Filter based on the type of file.</param>
        /// <param name="permission">Filter based on the permission of files (USER or COMPANY), defaults to BOTH.</param>
        /// <param name="viewable">Include public or private files in response (PUBLIC or PRIVATE), defaults to BOTH.</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<InfusioError, FileList>> ListFiles(string name = default, string type = default, string permission = default, string viewable = default, int? offset = default, int? limit = default) =>
            HttpWorkflow<FileList>(
                Request(HttpMethod.Get,
                    MakeUri($"/files",
                        RequestParameter("name", name),
                        RequestParameter("type", type),
                        RequestParameter("permission", permission),
                        RequestParameter("viewable", viewable),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(FileList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Files
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListFiles"/>.</remarks>
        /// <param name="name">Filter files based on name, with '*' preceding or following to indicate LIKE queries.</param>
        /// <param name="type">Filter based on the type of file.</param>
        /// <param name="permission">Filter based on the permission of files (USER or COMPANY), defaults to BOTH.</param>
        /// <param name="viewable">Include public or private files in response (PUBLIC or PRIVATE), defaults to BOTH.</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<FileList> ListFilesUnsafe(string name = default, string type = default, string permission = default, string viewable = default, int offset = default, int limit = default) => ListFiles(name, type, permission, viewable, offset, limit)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Upload File
        /// </summary>
        /// <param name="fileUpload">fileUploadDTO</param>
        public Task<Either<InfusioError, FileInformation>> CreateFile(Model.FileUpload fileUpload = default) =>
            HttpWorkflow<FileInformation>(
                Request(HttpMethod.Post,
                    MakeUri($"/files"),
                    fileUpload
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(FileInformation)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Upload File
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateFile"/>.</remarks>
        /// <param name="fileUpload">fileUploadDTO</param>
        public Task<FileInformation> CreateFileUnsafe(Model.FileUpload fileUpload = default) => CreateFile(fileUpload)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve File
        /// </summary>
        /// <param name="fileId">fileId</param>
        /// <param name="optionalProperties">Comma-delimited list of File properties to include in the response. (Some fields such as `file_data` aren't included, by default.)</param>
        public Task<Either<InfusioError, FileInformation>> GetFile(long? fileId, Lst<string> optionalProperties = default) =>
            HttpWorkflow<FileInformation>(
                Request(HttpMethod.Get,
                    MakeUri($"/files/{fileId}",
                        RequestParameter("optionalProperties", optionalProperties))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(FileInformation)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve File
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetFile"/>.</remarks>
        /// <param name="fileId">fileId</param>
        /// <param name="optionalProperties">Comma-delimited list of File properties to include in the response. (Some fields such as `file_data` aren't included, by default.)</param>
        public Task<FileInformation> GetFileUnsafe(long fileId, Lst<string> optionalProperties = default) => GetFile(fileId, optionalProperties)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Replace File
        /// </summary>
        /// <param name="fileId">fileId</param>
        /// <param name="fileUpload">fileUpload</param>
        public Task<Either<InfusioError, FileInformation>> UpdateFile(long? fileId, Model.FileUpload fileUpload = default) =>
            HttpWorkflow<FileInformation>(
                Request(HttpMethod.Put,
                    MakeUri($"/files/{fileId}"),
                    fileUpload
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(FileInformation)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Replace File
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="UpdateFile"/>.</remarks>
        /// <param name="fileId">fileId</param>
        /// <param name="fileUpload">fileUpload</param>
        public Task<FileInformation> UpdateFileUnsafe(long fileId, Model.FileUpload fileUpload = default) => UpdateFile(fileId, fileUpload)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Delete File
        /// </summary>
        /// <param name="fileId">fileId</param>
        public Task<Either<InfusioError, Unit>> DeleteFile(long? fileId) =>
            HttpWorkflow(
                Request(HttpMethod.Delete,
                    MakeUri($"/files/{fileId}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(204, "No Content", typeof(Unit)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Delete File
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="DeleteFile"/>.</remarks>
        /// <param name="fileId">fileId</param>
        public Task<Unit> DeleteFileUnsafe(long fileId) => DeleteFile(fileId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Stored Hook Subscriptions
        /// </summary>
        public Task<Either<InfusioError, Unit>> ListStoredHookSubscriptions() =>
            HttpWorkflow(
                Request(HttpMethod.Get,
                    MakeUri($"/hooks")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Unit)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Stored Hook Subscriptions
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListStoredHookSubscriptions"/>.</remarks>
        public Task<Unit> ListStoredHookSubscriptionsUnsafe() => ListStoredHookSubscriptions()
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Create a Hook Subscription
        /// </summary>
        /// <param name="restHookRequest">restHookRequest</param>
        public Task<Either<InfusioError, RestHook>> CreateAHookSubscription(Model.RestHookRequest restHookRequest) =>
            HttpWorkflow<RestHook>(
                Request(HttpMethod.Post,
                    MakeUri($"/hooks"),
                    restHookRequest
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(RestHook)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Create a Hook Subscription
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateAHookSubscription"/>.</remarks>
        /// <param name="restHookRequest">restHookRequest</param>
        public Task<RestHook> CreateAHookSubscriptionUnsafe(Model.RestHookRequest restHookRequest) => CreateAHookSubscription(restHookRequest)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Hook Event Types
        /// </summary>
        public Task<Either<InfusioError, Unit>> ListHookEventTypes() =>
            HttpWorkflow(
                Request(HttpMethod.Get,
                    MakeUri($"/hooks/event_keys")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Unit)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Hook Event Types
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListHookEventTypes"/>.</remarks>
        public Task<Unit> ListHookEventTypesUnsafe() => ListHookEventTypes()
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve a Hook Subscription
        /// </summary>
        /// <param name="key">key</param>
        public Task<Either<InfusioError, RestHook>> RetrieveAHookSubscription(string key) =>
            HttpWorkflow<RestHook>(
                Request(HttpMethod.Get,
                    MakeUri($"/hooks/{key}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(RestHook)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve a Hook Subscription
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveAHookSubscription"/>.</remarks>
        /// <param name="key">key</param>
        public Task<RestHook> RetrieveAHookSubscriptionUnsafe(string key) => RetrieveAHookSubscription(key)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Update a Hook Subscription
        /// </summary>
        /// <param name="restHookRequest">restHookRequest</param>
        /// <param name="key">key</param>
        public Task<Either<InfusioError, RestHook>> UpdateAHookSubscription(Model.RestHookRequest restHookRequest, string key) =>
            HttpWorkflow<RestHook>(
                Request(HttpMethod.Put,
                    MakeUri($"/hooks/{key}"),
                    restHookRequest
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(RestHook)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Update a Hook Subscription
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="UpdateAHookSubscription"/>.</remarks>
        /// <param name="restHookRequest">restHookRequest</param>
        /// <param name="key">key</param>
        public Task<RestHook> UpdateAHookSubscriptionUnsafe(Model.RestHookRequest restHookRequest, string key) => UpdateAHookSubscription(restHookRequest, key)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Delete a Hook Subscription
        /// </summary>
        /// <param name="key">key</param>
        public Task<Either<InfusioError, Unit>> DeleteAHookSubscription(string key) =>
            HttpWorkflow(
                Request(HttpMethod.Delete,
                    MakeUri($"/hooks/{key}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(204, "No Content", typeof(Unit)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Delete a Hook Subscription
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="DeleteAHookSubscription"/>.</remarks>
        /// <param name="key">key</param>
        public Task<Unit> DeleteAHookSubscriptionUnsafe(string key) => DeleteAHookSubscription(key)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Verify a Hook Subscription, Delayed
        /// </summary>
        /// <param name="xHookSecret">X-Hook-Secret</param>
        /// <param name="key">key</param>
        public Task<Either<InfusioError, RestHook>> VerifyAHookSubscriptionDelayed(string xHookSecret, string key) =>
            HttpWorkflow<RestHook>(
                Request(HttpMethod.Post,
                    MakeUri($"/hooks/{key}/delayedVerify")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(RestHook)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Verify a Hook Subscription, Delayed
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="VerifyAHookSubscriptionDelayed"/>.</remarks>
        /// <param name="xHookSecret">X-Hook-Secret</param>
        /// <param name="key">key</param>
        public Task<RestHook> VerifyAHookSubscriptionDelayedUnsafe(string xHookSecret, string key) => VerifyAHookSubscriptionDelayed(xHookSecret, key)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Verify a Hook Subscription
        /// </summary>
        /// <param name="key">key</param>
        public Task<Either<InfusioError, RestHook>> VerifyAHookSubscription(string key) =>
            HttpWorkflow<RestHook>(
                Request(HttpMethod.Post,
                    MakeUri($"/hooks/{key}/verify")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(RestHook)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Verify a Hook Subscription
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="VerifyAHookSubscription"/>.</remarks>
        /// <param name="key">key</param>
        public Task<RestHook> VerifyAHookSubscriptionUnsafe(string key) => VerifyAHookSubscription(key)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve User Info
        /// </summary>
        public Task<Either<InfusioError, UserInfoDTO>> GetUserInfo() =>
            HttpWorkflow<UserInfoDTO>(
                Request(HttpMethod.Get,
                    MakeUri($"/oauth/connect/userinfo")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(UserInfoDTO)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve User Info
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetUserInfo"/>.</remarks>
        public Task<UserInfoDTO> GetUserInfoUnsafe() => GetUserInfo()
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Opportunities
        /// </summary>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="searchTerm">Returns opportunities that match any of the contact's `given_name`, `family_name`, `company_name`, and `email_addresses` (searches `EMAIL1` only) fields as well as `opportunity_title`</param>
        /// <param name="stageId">Returns opportunities for the provided stage id</param>
        /// <param name="userId">Returns opportunities for the provided user id</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<InfusioError, OpportunityList>> ListOpportunities(string order = default, string searchTerm = default, long? stageId = default, long? userId = default, int? offset = default, int? limit = default) =>
            HttpWorkflow<OpportunityList>(
                Request(HttpMethod.Get,
                    MakeUri($"/opportunities",
                        RequestParameter("order", order),
                        RequestParameter("searchTerm", searchTerm),
                        RequestParameter("stageId", stageId),
                        RequestParameter("userId", userId),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(OpportunityList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Opportunities
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListOpportunities"/>.</remarks>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="searchTerm">Returns opportunities that match any of the contact's `given_name`, `family_name`, `company_name`, and `email_addresses` (searches `EMAIL1` only) fields as well as `opportunity_title`</param>
        /// <param name="stageId">Returns opportunities for the provided stage id</param>
        /// <param name="userId">Returns opportunities for the provided user id</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<OpportunityList> ListOpportunitiesUnsafe(string order = default, string searchTerm = default, long stageId = default, long userId = default, int offset = default, int limit = default) => ListOpportunities(order, searchTerm, stageId, userId, offset, limit)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Create an Opportunity
        /// </summary>
        /// <param name="opportunity">opportunity</param>
        public Task<Either<InfusioError, Opportunity>> CreateOpportunity(Model.Opportunity opportunity = default) =>
            HttpWorkflow<Opportunity>(
                Request(HttpMethod.Post,
                    MakeUri($"/opportunities"),
                    opportunity
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Opportunity)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Create an Opportunity
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateOpportunity"/>.</remarks>
        /// <param name="opportunity">opportunity</param>
        public Task<Opportunity> CreateOpportunityUnsafe(Model.Opportunity opportunity = default) => CreateOpportunity(opportunity)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Replace an Opportunity
        /// </summary>
        /// <param name="opportunity">opportunity</param>
        public Task<Either<InfusioError, Opportunity>> UpdateOpportunity(Model.Opportunity opportunity = default) =>
            HttpWorkflow<Opportunity>(
                Request(HttpMethod.Put,
                    MakeUri($"/opportunities"),
                    opportunity
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Opportunity)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Replace an Opportunity
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="UpdateOpportunity"/>.</remarks>
        /// <param name="opportunity">opportunity</param>
        public Task<Opportunity> UpdateOpportunityUnsafe(Model.Opportunity opportunity = default) => UpdateOpportunity(opportunity)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve Opportunity Model
        /// </summary>
        public Task<Either<InfusioError, ObjectModel>> RetrieveOpportunityModel() =>
            HttpWorkflow<ObjectModel>(
                Request(HttpMethod.Get,
                    MakeUri($"/opportunities/model")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(ObjectModel)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve Opportunity Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveOpportunityModel"/>.</remarks>
        public Task<ObjectModel> RetrieveOpportunityModelUnsafe() => RetrieveOpportunityModel()
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve an Opportunity
        /// </summary>
        /// <param name="opportunityId">opportunityId</param>
        /// <param name="optionalProperties">Comma-delimited list of Opportunity properties to include in the response. (Some fields such as `custom_fields` aren't included, by default.)</param>
        public Task<Either<InfusioError, Opportunity>> GetOpportunity(long? opportunityId, Lst<string> optionalProperties = default) =>
            HttpWorkflow<Opportunity>(
                Request(HttpMethod.Get,
                    MakeUri($"/opportunities/{opportunityId}",
                        RequestParameter("optionalProperties", optionalProperties))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Opportunity)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve an Opportunity
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetOpportunity"/>.</remarks>
        /// <param name="opportunityId">opportunityId</param>
        /// <param name="optionalProperties">Comma-delimited list of Opportunity properties to include in the response. (Some fields such as `custom_fields` aren't included, by default.)</param>
        public Task<Opportunity> GetOpportunityUnsafe(long opportunityId, Lst<string> optionalProperties = default) => GetOpportunity(opportunityId, optionalProperties)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Update an Opportunity
        /// </summary>
        /// <param name="opportunityId">opportunityId</param>
        /// <param name="opportunity">opportunity</param>
        public Task<Either<InfusioError, Opportunity>> UpdatePropertiesOnOpportunity(long? opportunityId, Model.Opportunity opportunity = default) =>
            HttpWorkflow<Opportunity>(
                Request(
                        new HttpMethod("Patch"),
                    MakeUri($"/opportunities/{opportunityId}"),
                    opportunity
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Opportunity)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Update an Opportunity
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="UpdatePropertiesOnOpportunity"/>.</remarks>
        /// <param name="opportunityId">opportunityId</param>
        /// <param name="opportunity">opportunity</param>
        public Task<Opportunity> UpdatePropertiesOnOpportunityUnsafe(long opportunityId, Model.Opportunity opportunity = default) => UpdatePropertiesOnOpportunity(opportunityId, opportunity)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Opportunity Stage Pipeline
        /// </summary>
        public Task<Either<InfusioError, Unit>> ListOpportunityStagePipelines() =>
            HttpWorkflow(
                Request(HttpMethod.Get,
                    MakeUri($"/opportunity/stage_pipeline")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Unit)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Opportunity Stage Pipeline
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListOpportunityStagePipelines"/>.</remarks>
        public Task<Unit> ListOpportunityStagePipelinesUnsafe() => ListOpportunityStagePipelines()
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Orders
        /// </summary>
        /// <param name="productId">Returns orders containing the provided product id</param>
        /// <param name="contactId">Returns orders for the provided contact id</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="paid">Sets paid status of items to return</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<Either<InfusioError, OrderList>> ListOrders(long? productId = default, long? contactId = default, string order = default, bool paid = default, int? offset = default, int? limit = default, string until = default, string since = default) =>
            HttpWorkflow<OrderList>(
                Request(HttpMethod.Get,
                    MakeUri($"/orders",
                        RequestParameter("productId", productId),
                        RequestParameter("contactId", contactId),
                        RequestParameter("order", order),
                        RequestParameter("paid", paid),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit),
                        RequestParameter("until", until),
                        RequestParameter("since", since))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(OrderList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Orders
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListOrders"/>.</remarks>
        /// <param name="productId">Returns orders containing the provided product id</param>
        /// <param name="contactId">Returns orders for the provided contact id</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="paid">Sets paid status of items to return</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<OrderList> ListOrdersUnsafe(long productId = default, long contactId = default, string order = default, bool paid = default, int offset = default, int limit = default, string until = default, string since = default) => ListOrders(productId, contactId, order, paid, offset, limit, until, since)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve Custom Order Model
        /// </summary>
        public Task<Either<InfusioError, ObjectModel>> RetrieveOrderModel() =>
            HttpWorkflow<ObjectModel>(
                Request(HttpMethod.Get,
                    MakeUri($"/orders/model")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(ObjectModel)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve Custom Order Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveOrderModel"/>.</remarks>
        public Task<ObjectModel> RetrieveOrderModelUnsafe() => RetrieveOrderModel()
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve an Order
        /// </summary>
        /// <param name="orderId">orderId</param>
        public Task<Either<InfusioError, Order>> GetOrder(long? orderId) =>
            HttpWorkflow<Order>(
                Request(HttpMethod.Get,
                    MakeUri($"/orders/{orderId}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Order)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve an Order
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetOrder"/>.</remarks>
        /// <param name="orderId">orderId</param>
        public Task<Order> GetOrderUnsafe(long orderId) => GetOrder(orderId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve Order Transactions
        /// </summary>
        /// <param name="orderId">orderId</param>
        /// <param name="contactId">Returns transactions for the provided contact id</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<Either<InfusioError, TransactionList>> ListTransactionsForOrder(long? orderId, long? contactId = default, int? offset = default, int? limit = default, string until = default, string since = default) =>
            HttpWorkflow<TransactionList>(
                Request(HttpMethod.Get,
                    MakeUri($"/orders/{orderId}/transactions",
                        RequestParameter("contactId", contactId),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit),
                        RequestParameter("until", until),
                        RequestParameter("since", since))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(TransactionList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve Order Transactions
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListTransactionsForOrder"/>.</remarks>
        /// <param name="orderId">orderId</param>
        /// <param name="contactId">Returns transactions for the provided contact id</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<TransactionList> ListTransactionsForOrderUnsafe(long orderId, long contactId = default, int offset = default, int limit = default, string until = default, string since = default) => ListTransactionsForOrder(orderId, contactId, offset, limit, until, since)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Products
        /// </summary>
        /// <param name="active">Sets status of items to return</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<InfusioError, ProductList>> ListProducts(bool active = default, int? offset = default, int? limit = default) =>
            HttpWorkflow<ProductList>(
                Request(HttpMethod.Get,
                    MakeUri($"/products",
                        RequestParameter("active", active),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(ProductList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Products
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListProducts"/>.</remarks>
        /// <param name="active">Sets status of items to return</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<ProductList> ListProductsUnsafe(bool active = default, int offset = default, int limit = default) => ListProducts(active, offset, limit)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve Synced Products
        /// </summary>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="syncToken">sync_token</param>
        public Task<Either<InfusioError, ProductStatusList>> ListProductsFromSyncToken(int? offset = default, int? limit = default, string syncToken = default) =>
            HttpWorkflow<ProductStatusList>(
                Request(HttpMethod.Get,
                    MakeUri($"/products/sync",
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit),
                        RequestParameter("syncToken", syncToken))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(ProductStatusList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve Synced Products
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListProductsFromSyncToken"/>.</remarks>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="syncToken">sync_token</param>
        public Task<ProductStatusList> ListProductsFromSyncTokenUnsafe(int offset = default, int limit = default, string syncToken = default) => ListProductsFromSyncToken(offset, limit, syncToken)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve a Product
        /// </summary>
        /// <param name="productId">productId</param>
        public Task<Either<InfusioError, Product>> GetProduct(long? productId) =>
            HttpWorkflow<Product>(
                Request(HttpMethod.Get,
                    MakeUri($"/products/{productId}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Product)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve a Product
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetProduct"/>.</remarks>
        /// <param name="productId">productId</param>
        public Task<Product> GetProductUnsafe(long productId) => GetProduct(productId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve application status
        /// </summary>
        public Task<Either<InfusioError, Setting>> GetApplicationEnabled() =>
            HttpWorkflow<Setting>(
                Request(HttpMethod.Get,
                    MakeUri($"/setting/application/enabled")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Setting)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve application status
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetApplicationEnabled"/>.</remarks>
        public Task<Setting> GetApplicationEnabledUnsafe() => GetApplicationEnabled()
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Contact types
        /// </summary>
        public Task<Either<InfusioError, Setting>> GetContactOptionTypes() =>
            HttpWorkflow<Setting>(
                Request(HttpMethod.Get,
                    MakeUri($"/setting/contact/optionTypes")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Setting)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Contact types
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetContactOptionTypes"/>.</remarks>
        public Task<Setting> GetContactOptionTypesUnsafe() => GetContactOptionTypes()
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve Subscription Model
        /// </summary>
        public Task<Either<InfusioError, ObjectModel>> RetrieveSubscriptionModel() =>
            HttpWorkflow<ObjectModel>(
                Request(HttpMethod.Get,
                    MakeUri($"/subscriptions/model")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(ObjectModel)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve Subscription Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveSubscriptionModel"/>.</remarks>
        public Task<ObjectModel> RetrieveSubscriptionModelUnsafe() => RetrieveSubscriptionModel()
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Tags
        /// </summary>
        /// <param name="category">Category Id of tags to filter by</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<InfusioError, Tags>> ListTags(long? category = default, int? offset = default, int? limit = default) =>
            HttpWorkflow<Tags>(
                Request(HttpMethod.Get,
                    MakeUri($"/tags",
                        RequestParameter("category", category),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Tags)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Tags
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListTags"/>.</remarks>
        /// <param name="category">Category Id of tags to filter by</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Tags> ListTagsUnsafe(long category = default, int offset = default, int limit = default) => ListTags(category, offset, limit)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Create Tag
        /// </summary>
        /// <param name="tag">tag</param>
        public Task<Either<InfusioError, Tag>> CreateTag(Model.CreateTag tag) =>
            HttpWorkflow<Tag>(
                Request(HttpMethod.Post,
                    MakeUri($"/tags"),
                    tag
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Tag)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Create Tag
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateTag"/>.</remarks>
        /// <param name="tag">tag</param>
        public Task<Tag> CreateTagUnsafe(Model.CreateTag tag) => CreateTag(tag)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Create Tag Category
        /// </summary>
        /// <param name="tagCategory">tagCategory</param>
        public Task<Either<InfusioError, TagCategory>> CreateTagCategory(Model.CreateTagCategory tagCategory) =>
            HttpWorkflow<TagCategory>(
                Request(HttpMethod.Post,
                    MakeUri($"/tags/categories"),
                    tagCategory
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(TagCategory)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Create Tag Category
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateTagCategory"/>.</remarks>
        /// <param name="tagCategory">tagCategory</param>
        public Task<TagCategory> CreateTagCategoryUnsafe(Model.CreateTagCategory tagCategory) => CreateTagCategory(tagCategory)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve a Tag
        /// </summary>
        /// <param name="id">id</param>
        public Task<Either<InfusioError, Tag>> GetTag(long? id) =>
            HttpWorkflow<Tag>(
                Request(HttpMethod.Get,
                    MakeUri($"/tags/{id}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Tag)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve a Tag
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetTag"/>.</remarks>
        /// <param name="id">id</param>
        public Task<Tag> GetTagUnsafe(long id) => GetTag(id)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Tagged Contacts
        /// </summary>
        /// <param name="tagId">tagId</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<InfusioError, TaggedContactList>> ListContactsForTagId(long? tagId, int? offset = default, int? limit = default) =>
            HttpWorkflow<TaggedContactList>(
                Request(HttpMethod.Get,
                    MakeUri($"/tags/{tagId}/contacts",
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(TaggedContactList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Tagged Contacts
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListContactsForTagId"/>.</remarks>
        /// <param name="tagId">tagId</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<TaggedContactList> ListContactsForTagIdUnsafe(long tagId, int offset = default, int limit = default) => ListContactsForTagId(tagId, offset, limit)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Apply Tag to Contacts
        /// </summary>
        /// <param name="ids">ids</param>
        /// <param name="tagId">tagId</param>
        public Task<Either<InfusioError, Unit>> ApplyTagToContactIds(Model.SetOfIds ids, long? tagId) =>
            HttpWorkflow(
                Request(HttpMethod.Post,
                    MakeUri($"/tags/{tagId}/contacts"),
                    ids
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Unit)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Apply Tag to Contacts
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ApplyTagToContactIds"/>.</remarks>
        /// <param name="ids">ids</param>
        /// <param name="tagId">tagId</param>
        public Task<Unit> ApplyTagToContactIdsUnsafe(Model.SetOfIds ids, long tagId) => ApplyTagToContactIds(ids, tagId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Remove Tag from Contacts
        /// </summary>
        /// <param name="ids">ids</param>
        /// <param name="tagId">tagId</param>
        public Task<Either<InfusioError, Unit>> RemoveTagFromContactIds(Lst<long> ids, long? tagId) =>
            HttpWorkflow(
                Request(HttpMethod.Delete,
                    MakeUri($"/tags/{tagId}/contacts",
                        RequestParameter("ids", ids))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(204, "No Content", typeof(Unit)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Remove Tag from Contacts
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RemoveTagFromContactIds"/>.</remarks>
        /// <param name="ids">ids</param>
        /// <param name="tagId">tagId</param>
        public Task<Unit> RemoveTagFromContactIdsUnsafe(Lst<long> ids, long tagId) => RemoveTagFromContactIds(ids, tagId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Remove Tag from Contact
        /// </summary>
        /// <param name="contactId">contactId</param>
        /// <param name="tagId">tagId</param>
        public Task<Either<InfusioError, Unit>> RemoveTagFromContactId(long? contactId, long? tagId) =>
            HttpWorkflow(
                Request(HttpMethod.Delete,
                    MakeUri($"/tags/{tagId}/contacts/{contactId}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(204, "No Content", typeof(Unit)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Remove Tag from Contact
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RemoveTagFromContactId"/>.</remarks>
        /// <param name="contactId">contactId</param>
        /// <param name="tagId">tagId</param>
        public Task<Unit> RemoveTagFromContactIdUnsafe(long contactId, long tagId) => RemoveTagFromContactId(contactId, tagId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Tasks
        /// </summary>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="completed">Sets completed status of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="userId">user_id</param>
        /// <param name="hasDueDate">has_due_date</param>
        /// <param name="contactId">contact_id</param>
        public Task<Either<InfusioError, TaskList>> ListTasks(string order = default, int? offset = default, int? limit = default, bool completed = default, string until = default, string since = default, long? userId = default, bool hasDueDate = default, long? contactId = default) =>
            HttpWorkflow<TaskList>(
                Request(HttpMethod.Get,
                    MakeUri($"/tasks",
                        RequestParameter("order", order),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit),
                        RequestParameter("completed", completed),
                        RequestParameter("until", until),
                        RequestParameter("since", since),
                        RequestParameter("userId", userId),
                        RequestParameter("hasDueDate", hasDueDate),
                        RequestParameter("contactId", contactId))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(TaskList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Tasks
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListTasks"/>.</remarks>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="completed">Sets completed status of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="userId">user_id</param>
        /// <param name="hasDueDate">has_due_date</param>
        /// <param name="contactId">contact_id</param>
        public Task<TaskList> ListTasksUnsafe(string order = default, int offset = default, int limit = default, bool completed = default, string until = default, string since = default, long userId = default, bool hasDueDate = default, long contactId = default) => ListTasks(order, offset, limit, completed, until, since, userId, hasDueDate, contactId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Create a Task
        /// </summary>
        /// <param name="task">task</param>
        public Task<Either<InfusioError, InfusionTask>> CreateTask(Model.InfusionTask task) =>
            HttpWorkflow<InfusionTask>(
                Request(HttpMethod.Post,
                    MakeUri($"/tasks"),
                    task
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(InfusionTask)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error))
            ));

        /// <summary>
        /// Create a Task
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateTask"/>.</remarks>
        /// <param name="task">task</param>
        public Task<InfusionTask> CreateTaskUnsafe(Model.InfusionTask task) => CreateTask(task)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve Task Model
        /// </summary>
        public Task<Either<InfusioError, ObjectModel>> RetrieveTaskModel() =>
            HttpWorkflow<ObjectModel>(
                Request(HttpMethod.Get,
                    MakeUri($"/tasks/model")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(ObjectModel)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve Task Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveTaskModel"/>.</remarks>
        public Task<ObjectModel> RetrieveTaskModelUnsafe() => RetrieveTaskModel()
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Search Tasks
        /// </summary>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="completed">Sets completed status of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="userId">Returns tasks for the provided user id</param>
        /// <param name="hasDueDate">Returns tasks that have an 'action date' when set to true</param>
        /// <param name="contactId">Returns tasks for the provided contact id</param>
        public Task<Either<InfusioError, TaskList>> ListTasksForCurrentUser(string order = default, int? offset = default, int? limit = default, bool completed = default, string until = default, string since = default, long? userId = default, bool hasDueDate = default, long? contactId = default) =>
            HttpWorkflow<TaskList>(
                Request(HttpMethod.Get,
                    MakeUri($"/tasks/search",
                        RequestParameter("order", order),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit),
                        RequestParameter("completed", completed),
                        RequestParameter("until", until),
                        RequestParameter("since", since),
                        RequestParameter("userId", userId),
                        RequestParameter("hasDueDate", hasDueDate),
                        RequestParameter("contactId", contactId))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(TaskList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Search Tasks
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListTasksForCurrentUser"/>.</remarks>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="completed">Sets completed status of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="userId">Returns tasks for the provided user id</param>
        /// <param name="hasDueDate">Returns tasks that have an 'action date' when set to true</param>
        /// <param name="contactId">Returns tasks for the provided contact id</param>
        public Task<TaskList> ListTasksForCurrentUserUnsafe(string order = default, int offset = default, int limit = default, bool completed = default, string until = default, string since = default, long userId = default, bool hasDueDate = default, long contactId = default) => ListTasksForCurrentUser(order, offset, limit, completed, until, since, userId, hasDueDate, contactId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve a Task
        /// </summary>
        /// <param name="taskId">taskId</param>
        public Task<Either<InfusioError, InfusionTask>> GetTask(string taskId) =>
            HttpWorkflow<InfusionTask>(
                Request(HttpMethod.Get,
                    MakeUri($"/tasks/{taskId}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(InfusionTask)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve a Task
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetTask"/>.</remarks>
        /// <param name="taskId">taskId</param>
        public Task<InfusionTask> GetTaskUnsafe(string taskId) => GetTask(taskId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Replace a Task
        /// </summary>
        /// <param name="task">task</param>
        /// <param name="taskId">taskId</param>
        public Task<Either<InfusioError, InfusionTask>> UpdateTask(Model.InfusionTask task, string taskId) =>
            HttpWorkflow<InfusionTask>(
                Request(HttpMethod.Put,
                    MakeUri($"/tasks/{taskId}"),
                    task
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(InfusionTask)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Replace a Task
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="UpdateTask"/>.</remarks>
        /// <param name="task">task</param>
        /// <param name="taskId">taskId</param>
        public Task<InfusionTask> UpdateTaskUnsafe(Model.InfusionTask task, string taskId) => UpdateTask(task, taskId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Delete a Task
        /// </summary>
        /// <param name="taskId">taskId</param>
        public Task<Either<InfusioError, Unit>> DeleteTask(string taskId) =>
            HttpWorkflow(
                Request(HttpMethod.Delete,
                    MakeUri($"/tasks/{taskId}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(204, "No Content", typeof(Unit)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Delete a Task
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="DeleteTask"/>.</remarks>
        /// <param name="taskId">taskId</param>
        public Task<Unit> DeleteTaskUnsafe(string taskId) => DeleteTask(taskId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Update a Task
        /// </summary>
        /// <param name="task">task</param>
        /// <param name="taskId">taskId</param>
        public Task<Either<InfusioError, InfusionTask>> UpdatePropertiesOnTask(Model.InfusionTask task, string taskId) =>
            HttpWorkflow<InfusionTask>(
                Request(
                        new HttpMethod("Patch"),
                    MakeUri($"/tasks/{taskId}"),
                    task
                ),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(InfusionTask)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Update a Task
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="UpdatePropertiesOnTask"/>.</remarks>
        /// <param name="task">task</param>
        /// <param name="taskId">taskId</param>
        public Task<InfusionTask> UpdatePropertiesOnTaskUnsafe(Model.InfusionTask task, string taskId) => UpdatePropertiesOnTask(task, taskId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// List Transactions
        /// </summary>
        /// <param name="contactId">Returns transactions for the provided contact id</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<Either<InfusioError, TransactionList>> ListTransactions(long? contactId = default, int? offset = default, int? limit = default, string until = default, string since = default) =>
            HttpWorkflow<TransactionList>(
                Request(HttpMethod.Get,
                    MakeUri($"/transactions",
                        RequestParameter("contactId", contactId),
                        RequestParameter("offset", offset),
                        RequestParameter("limit", limit),
                        RequestParameter("until", until),
                        RequestParameter("since", since))),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(TransactionList)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// List Transactions
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListTransactions"/>.</remarks>
        /// <param name="contactId">Returns transactions for the provided contact id</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<TransactionList> ListTransactionsUnsafe(long contactId = default, int offset = default, int limit = default, string until = default, string since = default) => ListTransactions(contactId, offset, limit, until, since)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));

        /// <summary>
        /// Retrieve a Transaction
        /// </summary>
        /// <param name="transactionId">transactionId</param>
        public Task<Either<InfusioError, Transaction>> GetTransaction(long? transactionId) =>
            HttpWorkflow<Transaction>(
                Request(HttpMethod.Get,
                    MakeUri($"/transactions/{transactionId}")),
                responses: HashSet<KnownResponse.Eq, KnownResponse>(
                    new KnownResponse(200, "OK", typeof(Transaction)),
                    new KnownResponse(401, "Unauthorized", typeof(Error)),
                    new KnownResponse(403, "Forbidden", typeof(Error)),
                    new KnownResponse(404, "Not Found", typeof(Error))
            ));

        /// <summary>
        /// Retrieve a Transaction
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetTransaction"/>.</remarks>
        /// <param name="transactionId">transactionId</param>
        public Task<Transaction> GetTransactionUnsafe(long transactionId) => GetTransaction(transactionId)
            .ToAsync()
            .IfLeftAsync(e => throw new Exception(e.Value));


        Task<Either<InfusioError, T>> HttpWorkflow<T>(HttpRequestMessage message, HashSet<KnownResponse.Eq, KnownResponse> responses) where T : class =>
            from httpResponse in SendRequest(message)
            from responseType in FindResponse(httpResponse, responses)
            from result in ReadResult<T>(httpResponse, responseType)
            select result;

        Task<Either<InfusioError, Unit>> HttpWorkflow(HttpRequestMessage message, HashSet<KnownResponse.Eq, KnownResponse> responses) =>
            from httpResponse in SendRequest(message)
            from responseType in FindResponse(httpResponse, responses)
            select unit;

        static readonly JsonSerializerSettings SerializerSettings = new JsonSerializerSettings
        {
            NullValueHandling = NullValueHandling.Ignore,
            ContractResolver = new CamelCasePropertyNamesContractResolver()
        };

        static Option<(string name, object value)> RequestParameter(string name, object value) =>
            Optional(value).Map(x => (name, x));

        static HttpContent MakeHttpContent(params Option<(string name, object value)>[] values) => ifNoneUnsafe(
            from body in Some(values.FoldT(HashMap<string, object>(), (acc, x) => acc.Add(x.name, x.value)))
            where !body.IsEmpty
            select new StringContent(SerializeObject(body, SerializerSettings)),
            () => null
        );

        string MakeUri(string relative, params Option<(string name, object value)>[] values) => ifNone(
            from pair in Some(values.FoldT(HashMap<string, object>(), (acc, x) => acc.Add(x.name, x.value)))
            where !pair.IsEmpty
            let qs = pair.Map((key, value) => $"{key}={value}").Values
            select $"{relative}?{string.Join("&", qs)}",
            relative
        );

        HttpRequestMessage Request(HttpMethod method, string relativeUrl, params Option<(string name, object value)>[] values) =>
            Request(method, relativeUrl, MakeHttpContent(values));

        HttpRequestMessage Request(HttpMethod method, string relativeUrl, object body) =>
            Request(method, relativeUrl, new StringContent(SerializeObject(body), Encoding.UTF8, "application/json"));

        HttpRequestMessage Request(HttpMethod method, string relativeUrl, HttpContent content) =>
            new HttpRequestMessage(method, $"https://api.infusionsoft.com/crm/rest/v1{relativeUrl}")
            {
                Content = content,
                Headers =
                {
                    Accept = { MediaTypeWithQualityHeaderValue.Parse("application/json")},
                    Authorization = new AuthenticationHeaderValue("Bearer", _config.AccessToken)
                }
            };

        Task<Either<InfusioError, KnownResponse>> FindResponse(HttpResponseMessage message, HashSet<KnownResponse.Eq, KnownResponse> responses) => match(
            responses.Find(KnownResponse.For(message.StatusCode)),
            None: () => message.Content.ReadAsStringAsync()
                .Map(x => Left<InfusioError, KnownResponse>(new InfusioError($"Unexpected response: {message.StatusCode} {x}"))),
            Some: response => Right<InfusioError, KnownResponse>(response).AsTask()
        );

        Task<Either<InfusioError, HttpResponseMessage>> SendRequest(HttpRequestMessage message) => match(
            TryAsync(() => _client.SendAsync(message)),
            Fail: e => Left<InfusioError, HttpResponseMessage>(new InfusioError($"Generic send InfusioError: {e.Message}")),
            Succ: x => Right<InfusioError, HttpResponseMessage>(x)
        );

        Task<Either<InfusioError, T>> ReadResult<T>(HttpResponseMessage message, KnownResponse response) where T : class =>
            !response.IsSuccess
            ? Left<InfusioError, T>(new InfusioError(response.Description)).AsTask()
            : match(
                from json in TryAsync(() => message.Content.ReadAsStringAsync())
                from result in Try(() => DeserializeObject(json, response.Type)).ToAsync()
                select result,
                Fail: e => Left<InfusioError, T>(new InfusioError($"Generic read InfusioError: {e.Message}")),
                Succ: t => match(
                    Optional((T)t),
                    None: () => Left<InfusioError, T>(new InfusioError($"Unable to read {typeof(T)}")),
                    Some: x => Right<InfusioError, T>(x)
                )
            );
    }

    public class KnownResponse : Record<KnownResponse>
    {
        public readonly int StatusCode;
        public readonly string Description;
        public readonly System.Type Type;
        public bool IsSuccess => (StatusCode >= 200) && (StatusCode <= 299);

        public KnownResponse(int statusCode, string description, System.Type type)
        {
            StatusCode = statusCode;
            Description = description;
            Type = type;
        }

        public static KnownResponse For(HttpStatusCode code) => new KnownResponse((int)code, "", null);

        public struct Eq : Eq<KnownResponse>
        {
            public bool Equals(KnownResponse x, KnownResponse y) => x.StatusCode.Equals(y.StatusCode);
            public int GetHashCode(KnownResponse x) => x.StatusCode.GetHashCode();
        }
    }
}