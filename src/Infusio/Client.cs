//----------------------
// <auto-generated>
// </auto-generated>
//----------------------
using System;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading.Tasks;

using Infusio.Model;
using LanguageExt;
using LanguageExt.TypeClasses;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Serialization;

// ReSharper disable RedundantStringInterpolation

namespace Infusio.Http
{
    using static Prelude;
    using static JsonConvert;

    public class InfusioClient
    {
        private readonly HttpClient _client;
        private readonly InfusioConfig _config;

        public InfusioClient(HttpClient client, InfusioConfig config)
        {
            _client = client;
            _config = config;
        }


        /// <summary>
        /// Retrieve account profile
        /// </summary>
        public Task<Either<Error, AccountProfile>> GetAccountProfile()
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(AccountProfile)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<AccountProfile>(
                    Request(HttpMethod.Get, $"/account/profile"),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve account profile
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetAccountProfile"/>.</remarks>
        public Task<AccountProfile> GetAccountProfileUnsafe() =>
GetAccountProfile()
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve Commissions
        /// </summary>
        /// <param name="affiliateId">Affiliate to retrieve commissions for</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<Either<Error, AffiliateCommissionList>> SearchCommissions(long affiliateId = default, int offset = default, int limit = default, string until = default, string since = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(AffiliateCommissionList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<AffiliateCommissionList>(
                    Request(HttpMethod.Get, $"/affiliates/commissions", ContentProperty("affiliateId", affiliateId), ContentProperty("offset", offset), ContentProperty("limit", limit), ContentProperty("until", until), ContentProperty("since", since)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve Commissions
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="SearchCommissions"/>.</remarks>
        /// <param name="affiliateId">Affiliate to retrieve commissions for</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<AffiliateCommissionList> SearchCommissionsUnsafe(long affiliateId = default, int offset = default, int limit = default, string until = default, string since = default) =>
SearchCommissions(affiliateId, offset, limit, until, since)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve Affiliate Model
        /// </summary>
        public Task<Either<Error, ObjectModel>> RetrieveAffiliateModel()
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(ObjectModel)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<ObjectModel>(
                    Request(HttpMethod.Get, $"/affiliates/model"),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve Affiliate Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveAffiliateModel"/>.</remarks>
        public Task<ObjectModel> RetrieveAffiliateModelUnsafe() =>
RetrieveAffiliateModel()
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Appointments
        /// </summary>
        /// <param name="contactId">Optionally find appointments with a contact</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<Either<Error, AppointmentList>> ListAppointments(long contactId = default, int offset = default, int limit = default, string until = default, string since = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(AppointmentList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<AppointmentList>(
                    Request(HttpMethod.Get, $"/appointments", ContentProperty("contactId", contactId), ContentProperty("offset", offset), ContentProperty("limit", limit), ContentProperty("until", until), ContentProperty("since", since)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Appointments
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListAppointments"/>.</remarks>
        /// <param name="contactId">Optionally find appointments with a contact</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<AppointmentList> ListAppointmentsUnsafe(long contactId = default, int offset = default, int limit = default, string until = default, string since = default) =>
ListAppointments(contactId, offset, limit, until, since)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve Appointment Model
        /// </summary>
        public Task<Either<Error, ObjectModel>> RetrieveAppointmentModel()
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(ObjectModel)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<ObjectModel>(
                    Request(HttpMethod.Get, $"/appointments/model"),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve Appointment Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveAppointmentModel"/>.</remarks>
        public Task<ObjectModel> RetrieveAppointmentModelUnsafe() =>
RetrieveAppointmentModel()
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve an Appointment
        /// </summary>
        /// <param name="appointmentId">appointmentId</param>
        public Task<Either<Error, Appointment>> GetAppointment(long appointmentId)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(Appointment)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Appointment>(
                    Request(HttpMethod.Get, $"/appointments/{appointmentId}", ContentProperty("appointmentId", appointmentId)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve an Appointment
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetAppointment"/>.</remarks>
        /// <param name="appointmentId">appointmentId</param>
        public Task<Appointment> GetAppointmentUnsafe(long appointmentId) =>
GetAppointment(appointmentId)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Campaigns
        /// </summary>
        /// <param name="orderDirection">How to order the data i.e. ascending (A-Z) or descending (Z-A)</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="searchText">Optional text to search</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<Error, CampaignList>> ListCampaigns(string orderDirection = default, string order = default, string searchText = default, int offset = default, int limit = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(CampaignList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<CampaignList>(
                    Request(HttpMethod.Get, $"/campaigns", ContentProperty("orderDirection", orderDirection), ContentProperty("order", order), ContentProperty("searchText", searchText), ContentProperty("offset", offset), ContentProperty("limit", limit)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Campaigns
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListCampaigns"/>.</remarks>
        /// <param name="orderDirection">How to order the data i.e. ascending (A-Z) or descending (Z-A)</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="searchText">Optional text to search</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<CampaignList> ListCampaignsUnsafe(string orderDirection = default, string order = default, string searchText = default, int offset = default, int limit = default) =>
ListCampaigns(orderDirection, order, searchText, offset, limit)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve a Campaign
        /// </summary>
        /// <param name="campaignId">campaignId</param>
        /// <param name="optionalProperties">Comma-delimited list of Campaign properties to include in the response. (The fields `goals` and `sequences` aren't included, by default.)</param>
        public Task<Either<Error, Campaign>> GetCampaign(long campaignId, Lst<string> optionalProperties = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(Campaign)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Campaign>(
                    Request(HttpMethod.Get, $"/campaigns/{campaignId}", ContentProperty("campaignId", campaignId), ContentProperty("optionalProperties", optionalProperties)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve a Campaign
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetCampaign"/>.</remarks>
        /// <param name="campaignId">campaignId</param>
        /// <param name="optionalProperties">Comma-delimited list of Campaign properties to include in the response. (The fields `goals` and `sequences` aren't included, by default.)</param>
        public Task<Campaign> GetCampaignUnsafe(long campaignId, Lst<string> optionalProperties = default) =>
GetCampaign(campaignId, optionalProperties)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Add Multiple to Campaign Sequence
        /// </summary>
        /// <param name="ids">ids</param>
        /// <param name="sequenceId">sequenceId</param>
        /// <param name="campaignId">campaignId</param>
        public Task<Either<Error, Nothing>> AddContactsToCampaignSequence(Model.SetOfIds ids, long sequenceId, long campaignId)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(204, "No Content", typeof(Unit)),
                  new KnownResponse(403, "Forbidden", typeof(Error))
                                );

            return HttpWorkflow<Nothing>(
                    Request(HttpMethod.Post, $"/campaigns/{campaignId}/sequences/{sequenceId}/contacts", ContentProperty("ids", ids), ContentProperty("sequenceId", sequenceId), ContentProperty("campaignId", campaignId)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Add Multiple to Campaign Sequence
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="AddContactsToCampaignSequence"/>.</remarks>
        /// <param name="ids">ids</param>
        /// <param name="sequenceId">sequenceId</param>
        /// <param name="campaignId">campaignId</param>
        public Task<Nothing> AddContactsToCampaignSequenceUnsafe(Model.SetOfIds ids, long sequenceId, long campaignId) =>
AddContactsToCampaignSequence(ids, sequenceId, campaignId)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Add to Campaign Sequence
        /// </summary>
        /// <param name="contactId">contactId</param>
        /// <param name="sequenceId">sequenceId</param>
        /// <param name="campaignId">campaignId</param>
        public Task<Either<Error, Nothing>> AddContactToCampaignSequence(long contactId, long sequenceId, long campaignId)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(204, "No Content", typeof(Unit)),
                  new KnownResponse(403, "Forbidden", typeof(Error))
                                );

            return HttpWorkflow<Nothing>(
                    Request(HttpMethod.Post, $"/campaigns/{campaignId}/sequences/{sequenceId}/contacts/{contactId}", ContentProperty("contactId", contactId), ContentProperty("sequenceId", sequenceId), ContentProperty("campaignId", campaignId)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Add to Campaign Sequence
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="AddContactToCampaignSequence"/>.</remarks>
        /// <param name="contactId">contactId</param>
        /// <param name="sequenceId">sequenceId</param>
        /// <param name="campaignId">campaignId</param>
        public Task<Nothing> AddContactToCampaignSequenceUnsafe(long contactId, long sequenceId, long campaignId) =>
AddContactToCampaignSequence(contactId, sequenceId, campaignId)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Companies
        /// </summary>
        /// <param name="optionalProperties">Comma-delimited list of Company properties to include in the response. (Fields such as `notes`, `fax_number` and `custom_fields` aren't included, by default.)</param>
        /// <param name="orderDirection">How to order the data i.e. ascending (A-Z) or descending (Z-A)</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="companyName">Optional company name to query on</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<Error, CompanyList>> ListCompanies(Lst<string> optionalProperties = default, string orderDirection = default, string order = default, string companyName = default, int offset = default, int limit = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(CompanyList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<CompanyList>(
                    Request(HttpMethod.Get, $"/companies", ContentProperty("optionalProperties", optionalProperties), ContentProperty("orderDirection", orderDirection), ContentProperty("order", order), ContentProperty("companyName", companyName), ContentProperty("offset", offset), ContentProperty("limit", limit)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Companies
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListCompanies"/>.</remarks>
        /// <param name="optionalProperties">Comma-delimited list of Company properties to include in the response. (Fields such as `notes`, `fax_number` and `custom_fields` aren't included, by default.)</param>
        /// <param name="orderDirection">How to order the data i.e. ascending (A-Z) or descending (Z-A)</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="companyName">Optional company name to query on</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<CompanyList> ListCompaniesUnsafe(Lst<string> optionalProperties = default, string orderDirection = default, string order = default, string companyName = default, int offset = default, int limit = default) =>
ListCompanies(optionalProperties, orderDirection, order, companyName, offset, limit)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve Company Model
        /// </summary>
        public Task<Either<Error, ObjectModel>> RetrieveCompanyModel()
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(ObjectModel)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<ObjectModel>(
                    Request(HttpMethod.Get, $"/companies/model"),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve Company Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveCompanyModel"/>.</remarks>
        public Task<ObjectModel> RetrieveCompanyModelUnsafe() =>
RetrieveCompanyModel()
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Contacts
        /// </summary>
        /// <param name="orderDirection">How to order the data i.e. ascending (A-Z) or descending (Z-A)</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="familyName">Optional last name or surname to query on</param>
        /// <param name="givenName">Optional first name or forename to query on</param>
        /// <param name="email">Optional email address to query on</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<Error, ContactList>> ListContacts(string orderDirection = default, string order = default, string familyName = default, string givenName = default, string email = default, int offset = default, int limit = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(ContactList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<ContactList>(
                    Request(HttpMethod.Get, $"/contacts", ContentProperty("orderDirection", orderDirection), ContentProperty("order", order), ContentProperty("familyName", familyName), ContentProperty("givenName", givenName), ContentProperty("email", email), ContentProperty("offset", offset), ContentProperty("limit", limit)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Contacts
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListContacts"/>.</remarks>
        /// <param name="orderDirection">How to order the data i.e. ascending (A-Z) or descending (Z-A)</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="familyName">Optional last name or surname to query on</param>
        /// <param name="givenName">Optional first name or forename to query on</param>
        /// <param name="email">Optional email address to query on</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<ContactList> ListContactsUnsafe(string orderDirection = default, string order = default, string familyName = default, string givenName = default, string email = default, int offset = default, int limit = default) =>
ListContacts(orderDirection, order, familyName, givenName, email, offset, limit)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve Contact Model
        /// </summary>
        public Task<Either<Error, ObjectModel>> RetrieveContactModel()
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(ObjectModel)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<ObjectModel>(
                    Request(HttpMethod.Get, $"/contacts/model"),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve Contact Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveContactModel"/>.</remarks>
        public Task<ObjectModel> RetrieveContactModelUnsafe() =>
RetrieveContactModel()
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Delete a Contact
        /// </summary>
        /// <param name="contactId">contactId</param>
        public Task<Either<Error, Nothing>> DeleteContact(long contactId)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(204, "No Content", typeof(Unit)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Nothing>(
                    Request(HttpMethod.Delete, $"/contacts/{contactId}", ContentProperty("contactId", contactId)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Delete a Contact
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="DeleteContact"/>.</remarks>
        /// <param name="contactId">contactId</param>
        public Task<Nothing> DeleteContactUnsafe(long contactId) =>
DeleteContact(contactId)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Create a Credit Card
        /// </summary>
        /// <param name="contactId">contactId</param>
        /// <param name="creditCard">creditCard</param>
        public Task<Either<Error, CreditCardAdded>> CreateCreditCard(long contactId, Model.CreditCard creditCard = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(201, "Created", typeof(CreditCardAdded)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error))
                                );

            return HttpWorkflow<CreditCardAdded>(
                    Request(HttpMethod.Post, $"/contacts/{contactId}/creditCards", ContentProperty("contactId", contactId), ContentProperty("creditCard", creditCard)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Create a Credit Card
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateCreditCard"/>.</remarks>
        /// <param name="contactId">contactId</param>
        /// <param name="creditCard">creditCard</param>
        public Task<CreditCardAdded> CreateCreditCardUnsafe(long contactId, Model.CreditCard creditCard = default) =>
CreateCreditCard(contactId, creditCard)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Emails
        /// </summary>
        /// <param name="contactId">contactId</param>
        /// <param name="email">Optional email address to query on</param>
        /// <param name="contactId2">Optional Contact Id to find Emails for</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<Error, EmailSentQueryResultList>> ListEmailsForContact(long contactId, string email = default, long contactId2 = default, int offset = default, int limit = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(EmailSentQueryResultList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<EmailSentQueryResultList>(
                    Request(HttpMethod.Get, $"/contacts/{contactId}/emails", ContentProperty("contactId", contactId), ContentProperty("email", email), ContentProperty("contactId2", contactId2), ContentProperty("offset", offset), ContentProperty("limit", limit)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Emails
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListEmailsForContact"/>.</remarks>
        /// <param name="contactId">contactId</param>
        /// <param name="email">Optional email address to query on</param>
        /// <param name="contactId2">Optional Contact Id to find Emails for</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<EmailSentQueryResultList> ListEmailsForContactUnsafe(long contactId, string email = default, long contactId2 = default, int offset = default, int limit = default) =>
ListEmailsForContact(contactId, email, contactId2, offset, limit)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Applied Tags
        /// </summary>
        /// <param name="contactId">contactId</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<Error, ContactTagList>> ListAppliedTags(long contactId, int offset = default, int limit = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(ContactTagList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<ContactTagList>(
                    Request(HttpMethod.Get, $"/contacts/{contactId}/tags", ContentProperty("contactId", contactId), ContentProperty("offset", offset), ContentProperty("limit", limit)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Applied Tags
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListAppliedTags"/>.</remarks>
        /// <param name="contactId">contactId</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<ContactTagList> ListAppliedTagsUnsafe(long contactId, int offset = default, int limit = default) =>
ListAppliedTags(contactId, offset, limit)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Remove Applied Tag
        /// </summary>
        /// <param name="tagId">tagId</param>
        /// <param name="contactId">contactId</param>
        public Task<Either<Error, Nothing>> RemoveTagsFromContact(long tagId, long contactId)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(204, "No Content", typeof(Unit)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Nothing>(
                    Request(HttpMethod.Delete, $"/contacts/{contactId}/tags/{tagId}", ContentProperty("tagId", tagId), ContentProperty("contactId", contactId)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Remove Applied Tag
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RemoveTagsFromContact"/>.</remarks>
        /// <param name="tagId">tagId</param>
        /// <param name="contactId">contactId</param>
        public Task<Nothing> RemoveTagsFromContactUnsafe(long tagId, long contactId) =>
RemoveTagsFromContact(tagId, contactId)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve a Contact
        /// </summary>
        /// <param name="id">id</param>
        /// <param name="optionalProperties">Comma-delimited list of Contact properties to include in the response. (Some fields such as `lead_source_id`, `custom_fields`, and `job_title` aren't included, by default.)</param>
        public Task<Either<Error, FullContact>> GetContact(long id, Lst<string> optionalProperties = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(FullContact)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<FullContact>(
                    Request(HttpMethod.Get, $"/contacts/{id}", ContentProperty("id", id), ContentProperty("optionalProperties", optionalProperties)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve a Contact
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetContact"/>.</remarks>
        /// <param name="id">id</param>
        /// <param name="optionalProperties">Comma-delimited list of Contact properties to include in the response. (Some fields such as `lead_source_id`, `custom_fields`, and `job_title` aren't included, by default.)</param>
        public Task<FullContact> GetContactUnsafe(long id, Lst<string> optionalProperties = default) =>
GetContact(id, optionalProperties)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Emails
        /// </summary>
        /// <param name="email">Optional email address to query on</param>
        /// <param name="contactId">Optional Contact Id to find Emails for</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<Error, EmailSentQueryResultList>> ListEmails(string email = default, long contactId = default, int offset = default, int limit = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(EmailSentQueryResultList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<EmailSentQueryResultList>(
                    Request(HttpMethod.Get, $"/emails", ContentProperty("email", email), ContentProperty("contactId", contactId), ContentProperty("offset", offset), ContentProperty("limit", limit)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Emails
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListEmails"/>.</remarks>
        /// <param name="email">Optional email address to query on</param>
        /// <param name="contactId">Optional Contact Id to find Emails for</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<EmailSentQueryResultList> ListEmailsUnsafe(string email = default, long contactId = default, int offset = default, int limit = default) =>
ListEmails(email, contactId, offset, limit)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Create a set of Email Records
        /// </summary>
        /// <param name="emailWithContent">Email records to persist, with content.</param>
        public Task<Either<Error, EmailSentCreateList>> CreateEmails(Model.EmailSentCreateList emailWithContent = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(201, "Created", typeof(EmailSentCreateList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error))
                                );

            return HttpWorkflow<EmailSentCreateList>(
                    Request(HttpMethod.Post, $"/emails/sync", ContentProperty("emailWithContent", emailWithContent)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Create a set of Email Records
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateEmails"/>.</remarks>
        /// <param name="emailWithContent">Email records to persist, with content.</param>
        public Task<EmailSentCreateList> CreateEmailsUnsafe(Model.EmailSentCreateList emailWithContent = default) =>
CreateEmails(emailWithContent)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Un-sync a batch of Email Records
        /// </summary>
        /// <param name="emailIds">emailIds</param>
        public Task<Either<Error, Nothing>> DeleteEmails(Model.SetOfIds emailIds)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(Unit)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error))
                                );

            return HttpWorkflow<Nothing>(
                    Request(HttpMethod.Post, $"/emails/unsync", ContentProperty("emailIds", emailIds)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Un-sync a batch of Email Records
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="DeleteEmails"/>.</remarks>
        /// <param name="emailIds">emailIds</param>
        public Task<Nothing> DeleteEmailsUnsafe(Model.SetOfIds emailIds) =>
DeleteEmails(emailIds)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve an Email
        /// </summary>
        /// <param name="id">id</param>
        public Task<Either<Error, EmailSentQueryResultWithContent>> GetEmail(long id)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(EmailSentQueryResultWithContent)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<EmailSentQueryResultWithContent>(
                    Request(HttpMethod.Get, $"/emails/{id}", ContentProperty("id", id)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve an Email
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetEmail"/>.</remarks>
        /// <param name="id">id</param>
        public Task<EmailSentQueryResultWithContent> GetEmailUnsafe(long id) =>
GetEmail(id)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Files
        /// </summary>
        /// <param name="name">Filter files based on name, with '*' preceding or following to indicate LIKE queries.</param>
        /// <param name="type">Filter based on the type of file.</param>
        /// <param name="permission">Filter based on the permission of files (USER or COMPANY), defaults to BOTH.</param>
        /// <param name="viewable">Include public or private files in response (PUBLIC or PRIVATE), defaults to BOTH.</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<Error, FileList>> ListFiles(string name = default, string type = default, string permission = default, string viewable = default, int offset = default, int limit = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(FileList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<FileList>(
                    Request(HttpMethod.Get, $"/files", ContentProperty("name", name), ContentProperty("type", type), ContentProperty("permission", permission), ContentProperty("viewable", viewable), ContentProperty("offset", offset), ContentProperty("limit", limit)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Files
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListFiles"/>.</remarks>
        /// <param name="name">Filter files based on name, with '*' preceding or following to indicate LIKE queries.</param>
        /// <param name="type">Filter based on the type of file.</param>
        /// <param name="permission">Filter based on the permission of files (USER or COMPANY), defaults to BOTH.</param>
        /// <param name="viewable">Include public or private files in response (PUBLIC or PRIVATE), defaults to BOTH.</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<FileList> ListFilesUnsafe(string name = default, string type = default, string permission = default, string viewable = default, int offset = default, int limit = default) =>
ListFiles(name, type, permission, viewable, offset, limit)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve File
        /// </summary>
        /// <param name="fileId">fileId</param>
        /// <param name="optionalProperties">Comma-delimited list of File properties to include in the response. (Some fields such as `file_data` aren't included, by default.)</param>
        public Task<Either<Error, FileInformation>> GetFile(long fileId, Lst<string> optionalProperties = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(FileInformation)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<FileInformation>(
                    Request(HttpMethod.Get, $"/files/{fileId}", ContentProperty("fileId", fileId), ContentProperty("optionalProperties", optionalProperties)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve File
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetFile"/>.</remarks>
        /// <param name="fileId">fileId</param>
        /// <param name="optionalProperties">Comma-delimited list of File properties to include in the response. (Some fields such as `file_data` aren't included, by default.)</param>
        public Task<FileInformation> GetFileUnsafe(long fileId, Lst<string> optionalProperties = default) =>
GetFile(fileId, optionalProperties)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Stored Hook Subscriptions
        /// </summary>
        public Task<Either<Error, Nothing>> ListStoredHookSubscriptions()
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(Unit)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Nothing>(
                    Request(HttpMethod.Get, $"/hooks"),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Stored Hook Subscriptions
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListStoredHookSubscriptions"/>.</remarks>
        public Task<Nothing> ListStoredHookSubscriptionsUnsafe() =>
ListStoredHookSubscriptions()
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Hook Event Types
        /// </summary>
        public Task<Either<Error, Nothing>> ListHookEventTypes()
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(Unit)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Nothing>(
                    Request(HttpMethod.Get, $"/hooks/event_keys"),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Hook Event Types
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListHookEventTypes"/>.</remarks>
        public Task<Nothing> ListHookEventTypesUnsafe() =>
ListHookEventTypes()
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve a Hook Subscription
        /// </summary>
        /// <param name="key">key</param>
        public Task<Either<Error, RestHook>> RetrieveAHookSubscription(string key)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(RestHook)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<RestHook>(
                    Request(HttpMethod.Get, $"/hooks/{key}", ContentProperty("key", key)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve a Hook Subscription
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveAHookSubscription"/>.</remarks>
        /// <param name="key">key</param>
        public Task<RestHook> RetrieveAHookSubscriptionUnsafe(string key) =>
RetrieveAHookSubscription(key)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Verify a Hook Subscription, Delayed
        /// </summary>
        /// <param name="xHookSecret">X-Hook-Secret</param>
        /// <param name="key">key</param>
        public Task<Either<Error, RestHook>> VerifyAHookSubscriptionDelayed(string xHookSecret, string key)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(RestHook)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error))
                                );

            return HttpWorkflow<RestHook>(
                    Request(HttpMethod.Post, $"/hooks/{key}/delayedVerify", ContentProperty("xHookSecret", xHookSecret), ContentProperty("key", key)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Verify a Hook Subscription, Delayed
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="VerifyAHookSubscriptionDelayed"/>.</remarks>
        /// <param name="xHookSecret">X-Hook-Secret</param>
        /// <param name="key">key</param>
        public Task<RestHook> VerifyAHookSubscriptionDelayedUnsafe(string xHookSecret, string key) =>
VerifyAHookSubscriptionDelayed(xHookSecret, key)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Verify a Hook Subscription
        /// </summary>
        /// <param name="key">key</param>
        public Task<Either<Error, RestHook>> VerifyAHookSubscription(string key)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(RestHook)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error))
                                );

            return HttpWorkflow<RestHook>(
                    Request(HttpMethod.Post, $"/hooks/{key}/verify", ContentProperty("key", key)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Verify a Hook Subscription
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="VerifyAHookSubscription"/>.</remarks>
        /// <param name="key">key</param>
        public Task<RestHook> VerifyAHookSubscriptionUnsafe(string key) =>
VerifyAHookSubscription(key)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve User Info
        /// </summary>
        public Task<Either<Error, UserInfoDTO>> GetUserInfo()
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(UserInfoDTO)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<UserInfoDTO>(
                    Request(HttpMethod.Get, $"/oauth/connect/userinfo"),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve User Info
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetUserInfo"/>.</remarks>
        public Task<UserInfoDTO> GetUserInfoUnsafe() =>
GetUserInfo()
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Opportunities
        /// </summary>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="searchTerm">Returns opportunities that match any of the contact's `given_name`, `family_name`, `company_name`, and `email_addresses` (searches `EMAIL1` only) fields as well as `opportunity_title`</param>
        /// <param name="stageId">Returns opportunities for the provided stage id</param>
        /// <param name="userId">Returns opportunities for the provided user id</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<Error, OpportunityList>> ListOpportunities(string order = default, string searchTerm = default, long stageId = default, long userId = default, int offset = default, int limit = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(OpportunityList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<OpportunityList>(
                    Request(HttpMethod.Get, $"/opportunities", ContentProperty("order", order), ContentProperty("searchTerm", searchTerm), ContentProperty("stageId", stageId), ContentProperty("userId", userId), ContentProperty("offset", offset), ContentProperty("limit", limit)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Opportunities
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListOpportunities"/>.</remarks>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="searchTerm">Returns opportunities that match any of the contact's `given_name`, `family_name`, `company_name`, and `email_addresses` (searches `EMAIL1` only) fields as well as `opportunity_title`</param>
        /// <param name="stageId">Returns opportunities for the provided stage id</param>
        /// <param name="userId">Returns opportunities for the provided user id</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<OpportunityList> ListOpportunitiesUnsafe(string order = default, string searchTerm = default, long stageId = default, long userId = default, int offset = default, int limit = default) =>
ListOpportunities(order, searchTerm, stageId, userId, offset, limit)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve Opportunity Model
        /// </summary>
        public Task<Either<Error, ObjectModel>> RetrieveOpportunityModel()
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(ObjectModel)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<ObjectModel>(
                    Request(HttpMethod.Get, $"/opportunities/model"),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve Opportunity Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveOpportunityModel"/>.</remarks>
        public Task<ObjectModel> RetrieveOpportunityModelUnsafe() =>
RetrieveOpportunityModel()
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve an Opportunity
        /// </summary>
        /// <param name="opportunityId">opportunityId</param>
        /// <param name="optionalProperties">Comma-delimited list of Opportunity properties to include in the response. (Some fields such as `custom_fields` aren't included, by default.)</param>
        public Task<Either<Error, Opportunity>> GetOpportunity(long opportunityId, Lst<string> optionalProperties = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(Opportunity)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Opportunity>(
                    Request(HttpMethod.Get, $"/opportunities/{opportunityId}", ContentProperty("opportunityId", opportunityId), ContentProperty("optionalProperties", optionalProperties)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve an Opportunity
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetOpportunity"/>.</remarks>
        /// <param name="opportunityId">opportunityId</param>
        /// <param name="optionalProperties">Comma-delimited list of Opportunity properties to include in the response. (Some fields such as `custom_fields` aren't included, by default.)</param>
        public Task<Opportunity> GetOpportunityUnsafe(long opportunityId, Lst<string> optionalProperties = default) =>
GetOpportunity(opportunityId, optionalProperties)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Opportunity Stage Pipeline
        /// </summary>
        public Task<Either<Error, Nothing>> ListOpportunityStagePipelines()
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(Unit)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Nothing>(
                    Request(HttpMethod.Get, $"/opportunity/stage_pipeline"),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Opportunity Stage Pipeline
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListOpportunityStagePipelines"/>.</remarks>
        public Task<Nothing> ListOpportunityStagePipelinesUnsafe() =>
ListOpportunityStagePipelines()
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Orders
        /// </summary>
        /// <param name="productId">Returns orders containing the provided product id</param>
        /// <param name="contactId">Returns orders for the provided contact id</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="paid">Sets paid status of items to return</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<Either<Error, OrderList>> ListOrders(long productId = default, long contactId = default, string order = default, bool paid = default, int offset = default, int limit = default, string until = default, string since = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(OrderList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<OrderList>(
                    Request(HttpMethod.Get, $"/orders", ContentProperty("productId", productId), ContentProperty("contactId", contactId), ContentProperty("order", order), ContentProperty("paid", paid), ContentProperty("offset", offset), ContentProperty("limit", limit), ContentProperty("until", until), ContentProperty("since", since)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Orders
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListOrders"/>.</remarks>
        /// <param name="productId">Returns orders containing the provided product id</param>
        /// <param name="contactId">Returns orders for the provided contact id</param>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="paid">Sets paid status of items to return</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<OrderList> ListOrdersUnsafe(long productId = default, long contactId = default, string order = default, bool paid = default, int offset = default, int limit = default, string until = default, string since = default) =>
ListOrders(productId, contactId, order, paid, offset, limit, until, since)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve Custom Order Model
        /// </summary>
        public Task<Either<Error, ObjectModel>> RetrieveOrderModel()
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(ObjectModel)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<ObjectModel>(
                    Request(HttpMethod.Get, $"/orders/model"),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve Custom Order Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveOrderModel"/>.</remarks>
        public Task<ObjectModel> RetrieveOrderModelUnsafe() =>
RetrieveOrderModel()
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve an Order
        /// </summary>
        /// <param name="orderId">orderId</param>
        public Task<Either<Error, Order>> GetOrder(long orderId)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(Order)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Order>(
                    Request(HttpMethod.Get, $"/orders/{orderId}", ContentProperty("orderId", orderId)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve an Order
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetOrder"/>.</remarks>
        /// <param name="orderId">orderId</param>
        public Task<Order> GetOrderUnsafe(long orderId) =>
GetOrder(orderId)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve Order Transactions
        /// </summary>
        /// <param name="orderId">orderId</param>
        /// <param name="contactId">Returns transactions for the provided contact id</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<Either<Error, TransactionList>> ListTransactionsForOrder(long orderId, long contactId = default, int offset = default, int limit = default, string until = default, string since = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(TransactionList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<TransactionList>(
                    Request(HttpMethod.Get, $"/orders/{orderId}/transactions", ContentProperty("orderId", orderId), ContentProperty("contactId", contactId), ContentProperty("offset", offset), ContentProperty("limit", limit), ContentProperty("until", until), ContentProperty("since", since)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve Order Transactions
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListTransactionsForOrder"/>.</remarks>
        /// <param name="orderId">orderId</param>
        /// <param name="contactId">Returns transactions for the provided contact id</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<TransactionList> ListTransactionsForOrderUnsafe(long orderId, long contactId = default, int offset = default, int limit = default, string until = default, string since = default) =>
ListTransactionsForOrder(orderId, contactId, offset, limit, until, since)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Products
        /// </summary>
        /// <param name="active">Sets status of items to return</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<Error, ProductList>> ListProducts(bool active = default, int offset = default, int limit = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(ProductList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<ProductList>(
                    Request(HttpMethod.Get, $"/products", ContentProperty("active", active), ContentProperty("offset", offset), ContentProperty("limit", limit)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Products
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListProducts"/>.</remarks>
        /// <param name="active">Sets status of items to return</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<ProductList> ListProductsUnsafe(bool active = default, int offset = default, int limit = default) =>
ListProducts(active, offset, limit)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve Synced Products
        /// </summary>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="syncToken">sync_token</param>
        public Task<Either<Error, ProductStatusList>> ListProductsFromSyncToken(int offset = default, int limit = default, string syncToken = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(ProductStatusList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<ProductStatusList>(
                    Request(HttpMethod.Get, $"/products/sync", ContentProperty("offset", offset), ContentProperty("limit", limit), ContentProperty("syncToken", syncToken)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve Synced Products
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListProductsFromSyncToken"/>.</remarks>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="syncToken">sync_token</param>
        public Task<ProductStatusList> ListProductsFromSyncTokenUnsafe(int offset = default, int limit = default, string syncToken = default) =>
ListProductsFromSyncToken(offset, limit, syncToken)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve a Product
        /// </summary>
        /// <param name="productId">productId</param>
        public Task<Either<Error, Product>> GetProduct(long productId)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(Product)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Product>(
                    Request(HttpMethod.Get, $"/products/{productId}", ContentProperty("productId", productId)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve a Product
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetProduct"/>.</remarks>
        /// <param name="productId">productId</param>
        public Task<Product> GetProductUnsafe(long productId) =>
GetProduct(productId)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve application status
        /// </summary>
        public Task<Either<Error, Setting>> GetApplicationEnabled()
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(Setting)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Setting>(
                    Request(HttpMethod.Get, $"/setting/application/enabled"),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve application status
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetApplicationEnabled"/>.</remarks>
        public Task<Setting> GetApplicationEnabledUnsafe() =>
GetApplicationEnabled()
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Contact types
        /// </summary>
        public Task<Either<Error, Setting>> GetContactOptionTypes()
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(Setting)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Setting>(
                    Request(HttpMethod.Get, $"/setting/contact/optionTypes"),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Contact types
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetContactOptionTypes"/>.</remarks>
        public Task<Setting> GetContactOptionTypesUnsafe() =>
GetContactOptionTypes()
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve Subscription Model
        /// </summary>
        public Task<Either<Error, ObjectModel>> RetrieveSubscriptionModel()
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(ObjectModel)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<ObjectModel>(
                    Request(HttpMethod.Get, $"/subscriptions/model"),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve Subscription Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveSubscriptionModel"/>.</remarks>
        public Task<ObjectModel> RetrieveSubscriptionModelUnsafe() =>
RetrieveSubscriptionModel()
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Tags
        /// </summary>
        /// <param name="category">Category Id of tags to filter by</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<Error, Tags>> ListTags(long category = default, int offset = default, int limit = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(Tags)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Tags>(
                    Request(HttpMethod.Get, $"/tags", ContentProperty("category", category), ContentProperty("offset", offset), ContentProperty("limit", limit)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Tags
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListTags"/>.</remarks>
        /// <param name="category">Category Id of tags to filter by</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Tags> ListTagsUnsafe(long category = default, int offset = default, int limit = default) =>
ListTags(category, offset, limit)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Create Tag Category
        /// </summary>
        /// <param name="tagCategory">tagCategory</param>
        public Task<Either<Error, TagCategory>> CreateTagCategory(Model.CreateTagCategory tagCategory)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(TagCategory)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error))
                                );

            return HttpWorkflow<TagCategory>(
                    Request(HttpMethod.Post, $"/tags/categories", ContentProperty("tagCategory", tagCategory)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Create Tag Category
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="CreateTagCategory"/>.</remarks>
        /// <param name="tagCategory">tagCategory</param>
        public Task<TagCategory> CreateTagCategoryUnsafe(Model.CreateTagCategory tagCategory) =>
CreateTagCategory(tagCategory)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve a Tag
        /// </summary>
        /// <param name="id">id</param>
        public Task<Either<Error, Tag>> GetTag(long id)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(Tag)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Tag>(
                    Request(HttpMethod.Get, $"/tags/{id}", ContentProperty("id", id)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve a Tag
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetTag"/>.</remarks>
        /// <param name="id">id</param>
        public Task<Tag> GetTagUnsafe(long id) =>
GetTag(id)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Tagged Contacts
        /// </summary>
        /// <param name="tagId">tagId</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<Either<Error, TaggedContactList>> ListContactsForTagId(long tagId, int offset = default, int limit = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(TaggedContactList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<TaggedContactList>(
                    Request(HttpMethod.Get, $"/tags/{tagId}/contacts", ContentProperty("tagId", tagId), ContentProperty("offset", offset), ContentProperty("limit", limit)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Tagged Contacts
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListContactsForTagId"/>.</remarks>
        /// <param name="tagId">tagId</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        public Task<TaggedContactList> ListContactsForTagIdUnsafe(long tagId, int offset = default, int limit = default) =>
ListContactsForTagId(tagId, offset, limit)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Remove Tag from Contact
        /// </summary>
        /// <param name="contactId">contactId</param>
        /// <param name="tagId">tagId</param>
        public Task<Either<Error, Nothing>> RemoveTagFromContactId(long contactId, long tagId)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(204, "No Content", typeof(Unit)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Nothing>(
                    Request(HttpMethod.Delete, $"/tags/{tagId}/contacts/{contactId}", ContentProperty("contactId", contactId), ContentProperty("tagId", tagId)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Remove Tag from Contact
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RemoveTagFromContactId"/>.</remarks>
        /// <param name="contactId">contactId</param>
        /// <param name="tagId">tagId</param>
        public Task<Nothing> RemoveTagFromContactIdUnsafe(long contactId, long tagId) =>
RemoveTagFromContactId(contactId, tagId)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Tasks
        /// </summary>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="completed">Sets completed status of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="userId">user_id</param>
        /// <param name="hasDueDate">has_due_date</param>
        /// <param name="contactId">contact_id</param>
        public Task<Either<Error, TaskList>> ListTasks(string order = default, int offset = default, int limit = default, bool completed = default, string until = default, string since = default, long userId = default, bool hasDueDate = default, long contactId = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(TaskList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<TaskList>(
                    Request(HttpMethod.Get, $"/tasks", ContentProperty("order", order), ContentProperty("offset", offset), ContentProperty("limit", limit), ContentProperty("completed", completed), ContentProperty("until", until), ContentProperty("since", since), ContentProperty("userId", userId), ContentProperty("hasDueDate", hasDueDate), ContentProperty("contactId", contactId)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Tasks
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListTasks"/>.</remarks>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="completed">Sets completed status of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="userId">user_id</param>
        /// <param name="hasDueDate">has_due_date</param>
        /// <param name="contactId">contact_id</param>
        public Task<TaskList> ListTasksUnsafe(string order = default, int offset = default, int limit = default, bool completed = default, string until = default, string since = default, long userId = default, bool hasDueDate = default, long contactId = default) =>
ListTasks(order, offset, limit, completed, until, since, userId, hasDueDate, contactId)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve Task Model
        /// </summary>
        public Task<Either<Error, ObjectModel>> RetrieveTaskModel()
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(ObjectModel)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<ObjectModel>(
                    Request(HttpMethod.Get, $"/tasks/model"),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve Task Model
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="RetrieveTaskModel"/>.</remarks>
        public Task<ObjectModel> RetrieveTaskModelUnsafe() =>
RetrieveTaskModel()
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Search Tasks
        /// </summary>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="completed">Sets completed status of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="userId">Returns tasks for the provided user id</param>
        /// <param name="hasDueDate">Returns tasks that have an 'action date' when set to true</param>
        /// <param name="contactId">Returns tasks for the provided contact id</param>
        public Task<Either<Error, TaskList>> ListTasksForCurrentUser(string order = default, int offset = default, int limit = default, bool completed = default, string until = default, string since = default, long userId = default, bool hasDueDate = default, long contactId = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(TaskList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<TaskList>(
                    Request(HttpMethod.Get, $"/tasks/search", ContentProperty("order", order), ContentProperty("offset", offset), ContentProperty("limit", limit), ContentProperty("completed", completed), ContentProperty("until", until), ContentProperty("since", since), ContentProperty("userId", userId), ContentProperty("hasDueDate", hasDueDate), ContentProperty("contactId", contactId)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Search Tasks
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListTasksForCurrentUser"/>.</remarks>
        /// <param name="order">Attribute to order items by</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="completed">Sets completed status of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="userId">Returns tasks for the provided user id</param>
        /// <param name="hasDueDate">Returns tasks that have an 'action date' when set to true</param>
        /// <param name="contactId">Returns tasks for the provided contact id</param>
        public Task<TaskList> ListTasksForCurrentUserUnsafe(string order = default, int offset = default, int limit = default, bool completed = default, string until = default, string since = default, long userId = default, bool hasDueDate = default, long contactId = default) =>
ListTasksForCurrentUser(order, offset, limit, completed, until, since, userId, hasDueDate, contactId)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve a Task
        /// </summary>
        /// <param name="taskId">taskId</param>
        public Task<Either<Error, InfusionTask>> GetTask(string taskId)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(InfusionTask)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<InfusionTask>(
                    Request(HttpMethod.Get, $"/tasks/{taskId}", ContentProperty("taskId", taskId)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve a Task
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetTask"/>.</remarks>
        /// <param name="taskId">taskId</param>
        public Task<InfusionTask> GetTaskUnsafe(string taskId) =>
GetTask(taskId)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// List Transactions
        /// </summary>
        /// <param name="contactId">Returns transactions for the provided contact id</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<Either<Error, TransactionList>> ListTransactions(long contactId = default, int offset = default, int limit = default, string until = default, string since = default)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(TransactionList)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<TransactionList>(
                    Request(HttpMethod.Get, $"/transactions", ContentProperty("contactId", contactId), ContentProperty("offset", offset), ContentProperty("limit", limit), ContentProperty("until", until), ContentProperty("since", since)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// List Transactions
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="ListTransactions"/>.</remarks>
        /// <param name="contactId">Returns transactions for the provided contact id</param>
        /// <param name="offset">Sets a beginning range of items to return</param>
        /// <param name="limit">Sets a total of items to return</param>
        /// <param name="until">Date to search to ex. `2017-01-01T22:17:59.039Z`</param>
        /// <param name="since">Date to start searching from ex. `2017-01-01T22:17:59.039Z`</param>
        public Task<TransactionList> ListTransactionsUnsafe(long contactId = default, int offset = default, int limit = default, string until = default, string since = default) =>
ListTransactions(contactId, offset, limit, until, since)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));


        /// <summary>
        /// Retrieve a Transaction
        /// </summary>
        /// <param name="transactionId">transactionId</param>
        public Task<Either<Error, Transaction>> GetTransaction(long transactionId)
        {
            var responses = HashSet<KnownResponse.Eq, KnownResponse>(
                  new KnownResponse(200, "OK", typeof(Transaction)),
                  new KnownResponse(401, "Unauthorized", typeof(Error)),
                  new KnownResponse(403, "Forbidden", typeof(Error)),
                  new KnownResponse(404, "Not Found", typeof(Error))
                                );

            return HttpWorkflow<Transaction>(
                    Request(HttpMethod.Get, $"/transactions/{transactionId}", ContentProperty("transactionId", transactionId)),
                    responses
                ).ToEither();
        }

        /// <summary>
        /// Retrieve a Transaction
        /// </summary>
        /// <remarks>Does not catch exceptions. It is preferred to use <see cref="GetTransaction"/>.</remarks>
        /// <param name="transactionId">transactionId</param>
        public Task<Transaction> GetTransactionUnsafe(long transactionId) =>
GetTransaction(transactionId)
    .ToAsync()
    .IfLeftAsync(e => throw new Exception(e.Message));



        EitherAsync<Error, T> HttpWorkflow<T>(HttpRequestMessage message, HashSet<KnownResponse.Eq, KnownResponse> responses) where T : class => use(message,
            msg =>
                from httpResponse in SendRequest(msg)
                from responseType in FindResponse(httpResponse, responses)
                from result in ReadResult<T>(httpResponse, responseType)
                select result
        );

        static readonly JsonSerializerSettings SerializerSettings = new JsonSerializerSettings
        {
            NullValueHandling = NullValueHandling.Ignore,
            ContractResolver = new CamelCasePropertyNamesContractResolver(),
            Converters =
            {
                new StringEnumConverter()
            }
        };

        static Option<(string name, object value)> ContentProperty(string name, object value) =>
            Optional(value).Map(x => (name, x));

        static HttpContent MakeHttpContent(params Option<(string name, object value)>[] values) => ifNoneUnsafe(
            from body in Some(values.FoldT(HashMap<string, object>(), (acc, x) => acc.Add(x.name, x.value)))
            where !body.IsEmpty
            select new StringContent(SerializeObject(body, SerializerSettings)),
            () => null
        );

        HttpRequestMessage Request(HttpMethod method, string relativeUrl, params Option<(string name, object value)>[] values) =>
            new HttpRequestMessage(method, $"https://api.infusionsoft.com/crm/rest/v1/{relativeUrl}")
            {
                Content = MakeHttpContent(values),
                Headers =
                {
                    Accept = { MediaTypeWithQualityHeaderValue.Parse("application/json")},
                    Authorization = new AuthenticationHeaderValue("Bearer", _config.ApiKey)
                }
            };

        EitherAsync<Error, KnownResponse> FindResponse(HttpResponseMessage message, HashSet<KnownResponse.Eq, KnownResponse> responses) => match(
            responses.Find(KnownResponse.For(message.StatusCode)),
            None: () => Left(new Error(message: $"Unexpected response: {message.StatusCode}")),
            Some: response => Right<Error, KnownResponse>(response)
        ).ToAsync();

        EitherAsync<Error, HttpResponseMessage> SendRequest(HttpRequestMessage message) => match(
            TryAsync(() => _client.SendAsync(message)),
            Fail: e => Left<Error, HttpResponseMessage>(new Error(message: $"Generic send error: {e.Message}")),
            Succ: x => Right<Error, HttpResponseMessage>(x)
        ).ToAsync();

        EitherAsync<Error, T> ReadResult<T>(HttpResponseMessage message, KnownResponse response) where T : class =>
            !response.IsSuccess ?
            LeftAsync<Error, T>(new Error(message: response.Description).AsTask())
            : response.Type == typeof(Nothing)
                ? RightAsync<Error, T>((Nothing.Inst as T).AsTask())
                : match(
                    from json in TryAsync(message.Content.ReadAsStringAsync())
                    from result in Try(DeserializeObject(json, response.Type)).ToAsync()
                    select result,
                    Fail: e => Left<Error, T>(new Error(message: $"Generic read error: {e.Message}")),
                    Succ: t => match(
                        Optional((T)t),
                        None: () => Left<Error, T>(new Error(message: $"Unable to read {typeof(T)}")),
                        Some: x => Right<Error, T>(x)
                    )
                ).ToAsync();
    }

    public class KnownResponse : Record<KnownResponse>
    {
        public readonly int StatusCode;
        public readonly string Description;
        public readonly System.Type Type;
        public bool IsSuccess => (StatusCode >= 200) && (StatusCode <= 299);

        public KnownResponse(int statusCode, string description, System.Type type)
        {
            StatusCode = statusCode;
            Description = description;
            Type = type;
        }

        public static KnownResponse For(HttpStatusCode code) => new KnownResponse((int)code, "", null);

        public struct Eq : Eq<KnownResponse>
        {
            public bool Equals(KnownResponse x, KnownResponse y) => x.StatusCode.Equals(y.StatusCode);
            public int GetHashCode(KnownResponse x) => x.StatusCode.GetHashCode();
        }
    }

    public class Nothing
    {
        Nothing() { }
        public static Nothing Inst = new Nothing();
        public static implicit operator Unit(Nothing n) => unit;
    }
}